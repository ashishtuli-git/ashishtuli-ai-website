<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ashish Tuli</title>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">

  <style>
    /* -------------------------------------------
       LAYOUT & ATMOSPHERE
       ------------------------------------------- */
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      overflow: hidden; 
      font-family: 'Inter', sans-serif;
      background: #0a0d1a; /* Fallback */
    }

    /* Deep Space Gradient Animation */
    @keyframes deepSpace {
      0%   { background: linear-gradient(135deg, #05070a, #0f172a); }
      50%  { background: linear-gradient(135deg, #0a0f1f, #1e293b); }
      100% { background: linear-gradient(135deg, #0f172a, #263c5e); }
    }
    body.sunset { 
      animation: deepSpace 30s ease-in-out infinite alternate; 
    }

    /* The Neural Canvas */
    #neuralCanvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 1;
    }

    /* -------------------------------------------
       GLASSMORPHISM UI (FROSTED GLASS)
       ------------------------------------------- */
    .ui-container {
        padding: 0.8rem 1.2rem;
        border-radius: 12px;
        background: rgba(10, 15, 30, 0.4); /* Darker tint for better contrast */
        backdrop-filter: blur(12px); 
        -webkit-backdrop-filter: blur(12px);
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
        transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
    }
    .ui-container:hover {
        background: rgba(30, 40, 60, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.2);
        transform: translateY(-2px) scale(1.01);
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
    }

    /* -------------------------------------------
       UI ELEMENTS POSITIONS
       ------------------------------------------- */
    /* Top Left: Socials */
    .top-left-links {
      position: absolute; top: 30px; left: 30px;
      z-index: 10; display: flex; gap: 24px; align-items: center;
    }
    .link-text {
      font-weight: 500; text-decoration: none;
      color: #e2e8f0; letter-spacing: 0.5px;
      position: relative;
    }
    .link-text::after {
      content: ''; position: absolute; width: 0; height: 1px;
      bottom: -4px; left: 0; background-color: #60a5fa;
      transition: width 0.3s;
    }
    .link-text:hover::after { width: 100%; }
    
    .double-struck-x {
      font-weight: 700; text-decoration: none; font-size: 1.3rem; color: #e2e8f0;
    }

    /* Top Right: Bitcoin Data */
    #bitcoinInfo {
      position: absolute; top: 30px; right: 30px;
      z-index: 10; color: #cbd5e1;
      font-size: 0.85rem; font-weight: 400;
      text-align: right; line-height: 1.5;
      padding: 0.8rem 1.2rem;
    }
    .btc-label { font-size: 0.75rem; color: #94a3b8; text-transform: uppercase; letter-spacing: 1px; }
    .btc-val { font-weight: 600; color: #fff; }

    /* Bottom Left: World Clocks */
    .visitor-info {
      position: absolute; bottom: 30px; left: 30px;
      z-index: 10; font-size: 0.8rem; color: #94a3b8;
      line-height: 1.8;
      display: grid; grid-template-columns: 1fr; gap: 4px;
    }
    .clock-row { display: flex; justify-content: space-between; min-width: 200px; gap: 15px; border-bottom: 1px solid rgba(255,255,255,0.05); padding-bottom: 2px;}
    .clock-city { font-weight: 500; color: #cbd5e1; }

    /* Bottom Right: Quotes */
    .quotes {
      position: absolute; bottom: 30px; right: 30px;
      z-index: 10; max-width: 360px;
      font-size: 0.95rem; font-style: italic;
      color: #e2e8f0; text-align: right;
      border-left: none; border-right: 3px solid #60a5fa; /* Blue accent bar */
    }

    /* Mobile Responsive */
    @media (max-width: 768px) {
      .visitor-info { bottom: 90px; left: 20px; font-size: 0.75rem; }
      .quotes { bottom: 20px; right: 20px; font-size: 0.8rem; max-width: 260px; }
      .top-left-links { top: 20px; left: 20px; gap: 15px; }
      #bitcoinInfo { top: 20px; right: 20px; padding: 0.6rem; }
    }
  </style>
</head>
<body class="sunset">
  
  <canvas id="neuralCanvas"></canvas>

  <div class="top-left-links ui-container">
    <a href="https://www.linkedin.com/in/ashishtuli" target="_blank" class="link-text">LinkedIn</a>
    <a href="https://x.com/ashishtuli" target="_blank" class="double-struck-x">&#x1D54F;</a>
  </div>

  <div id="bitcoinInfo" class="ui-container">
    <span class="btc-label">Initializing</span><br>
    <span class="btc-val">Stream...</span>
  </div>

  <div class="visitor-info ui-container" id="visitorInfo">
    </div>

  <div class="quotes ui-container" id="quotesBox"></div>

  <script>
    /**
     * ==========================================================
     * 3D NEURAL NETWORK ENGINE (The "Wow" Factor)
     * Features: Synaptic Firing, Z-Depth Parallax, Smart Mouse
     * ==========================================================
     */
    const canvas = document.getElementById('neuralCanvas');
    const ctx = canvas.getContext('2d');
    
    // Config
    let width, height;
    const nodeCount = window.innerWidth < 768 ? 40 : 130; // Dense network
    const connectionDist = 140; 
    const mouseRadius = 250;
    
    // State
    let nodes = [];
    let pulses = []; // Synaptic signals
    let mouse = { x: null, y: null };
    
    // Colors
    const colorActive = { h: 210, s: 70, l: 60 };  // Electric Blue
    const colorFrozen = { h: 340, s: 80, l: 60 };  // Hot Pink/Crimson
    
    // Logic Flags
    let cascadeActive = false;
    let resetMode = false;
    let resetScheduled = false;

    // --- SETUP & RESIZE ---
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      ctx.scale(dpr, dpr);
      canvas.style.width = width + "px";
      canvas.style.height = height + "px";
    }
    window.addEventListener('resize', () => { resize(); initNodes(); });
    window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
    window.addEventListener('mouseout', () => { mouse.x = null; mouse.y = null; });
    resize();

    // --- INITIALIZATION ---
    function initNodes() {
      nodes = [];
      pulses = [];
      for(let i=0; i<nodeCount; i++) {
        const z = Math.random(); // Depth: 0 (back) to 1 (front)
        nodes.push({
          x: Math.random() * width,
          y: Math.random() * height,
          z: z, // Depth
          
          // Velocity scales with depth (Parallax effect)
          vx: (Math.random() - 0.5) * (0.2 + z * 0.5), 
          vy: (Math.random() - 0.5) * (0.2 + z * 0.5),
          
          originalVx: 0, originalVy: 0, // For freezing logic
          
          // State
          radius: 1.5 + (z * 2.5), // Closer nodes are bigger
          connections: 0,
          isStopped: false,
          freezeAt: undefined,
          unfreezeAt: undefined,
          
          // Visuals
          pulseVal: 0 // Flash intensity when hit by a signal
        });
      }
    }
    initNodes();

    // --- ANIMATION LOOP ---
    function animate() {
      ctx.clearRect(0, 0, width, height);
      
      // 1. Update Nodes
      nodes.forEach(n => {
        n.connections = 0; // Reset count
        
        // Decay pulse visual
        if(n.pulseVal > 0) n.pulseVal -= 0.05;

        // Freeze/Cascade Logic (Preserved from original request)
        if (!n.isStopped) {
          // --- MOUSE INTERACTION (Gravity + Swirl) ---
          if (mouse.x !== null) {
            let dx = mouse.x - n.x;
            let dy = mouse.y - n.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            
            // Influence creates a gentle swirl around the mouse
            if (dist < mouseRadius) {
              const force = (mouseRadius - dist) / mouseRadius;
              const influence = force * 0.03 * n.z; // Closer nodes react more
              
              n.vx += (dx / dist) * influence; // Attract
              n.vy += (dy / dist) * influence;
            }
          }

          // Speed Limit (Dampening)
          const speed = Math.sqrt(n.vx*n.vx + n.vy*n.vy);
          const maxSpeed = 0.5 + (n.z * 1.5); // Front nodes move faster
          if (speed > maxSpeed) {
            n.vx *= 0.95; n.vy *= 0.95;
          }

          // Move
          n.x += n.vx; n.y += n.vy;

          // Wrap around screen
          if (n.x < -50) n.x = width + 50;
          if (n.x > width + 50) n.x = -50;
          if (n.y < -50) n.y = height + 50;
          if (n.y > height + 50) n.y = -50;
        }

        // Logic processing (freezing/thawing timers)
        handleCascadeLogic(n);
      });

      // 2. Draw Connections & Spawn Pulses
      ctx.lineWidth = 0.5;
      
      // We loop O(N^2) but optimized by distance check
      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          let n1 = nodes[i];
          let n2 = nodes[j];
          
          let dx = n1.x - n2.x;
          let dy = n1.y - n2.y;
          let distSq = dx*dx + dy*dy;
          
          // Threshold check (squared to avoid sqrt for performance)
          if (distSq < connectionDist * connectionDist) {
            // Check freeze rules
            if ((n1.isStopped !== n2.isStopped)) continue; // Don't connect different states
            
            n1.connections++;
            n2.connections++;
            
            // Calculate opacity based on Z-depth average
            const zAvg = (n1.z + n2.z) / 2;
            const opacity = 0.15 + (zAvg * 0.3); // Deeper lines are fainter
            
            // Color logic
            let strokeColor;
            if (n1.isStopped) {
               strokeColor = `hsla(${colorFrozen.h}, ${colorFrozen.s}%, ${colorFrozen.l}%, ${opacity})`;
            } else {
               strokeColor = `hsla(${colorActive.h}, ${colorActive.s}%, ${colorActive.l}%, ${opacity})`;
            }

            ctx.beginPath();
            ctx.strokeStyle = strokeColor;
            ctx.moveTo(n1.x, n1.y);
            ctx.lineTo(n2.x, n2.y);
            ctx.stroke();

            // --- SYNAPTIC FIRING (The Spark) ---
            // Random chance to fire a signal pulse between connected nodes
            // Chance increases if nodes are highly connected or near mouse
            if (!n1.isStopped && Math.random() < 0.002) {
              pulses.push({
                x: n1.x, y: n1.y,
                tx: n2.x, ty: n2.y,
                z: zAvg,
                progress: 0,
                speed: 0.02 + Math.random() * 0.03
              });
            }
          }
        }
      }

      // 3. Draw & Update Pulses (Synapses)
      for (let i = pulses.length - 1; i >= 0; i--) {
        let p = pulses[i];
        p.progress += p.speed;
        
        if (p.progress >= 1) {
          pulses.splice(i, 1);
          continue; // Signal reached destination
        }

        // Lerp position
        let curX = p.x + (p.tx - p.x) * p.progress;
        let curY = p.y + (p.ty - p.y) * p.progress;
        
        // Draw glowing dot
        const size = 1.5 + p.z;
        ctx.beginPath();
        ctx.arc(curX, curY, size, 0, Math.PI*2);
        ctx.fillStyle = `rgba(255, 255, 255, ${0.8 + (0.2 * p.z)})`;
        ctx.shadowBlur = 10;
        ctx.shadowColor = "white";
        ctx.fill();
        ctx.shadowBlur = 0; // Reset
      }

      // 4. Draw Nodes
      nodes.forEach(n => {
        ctx.beginPath();
        const drawRadius = n.radius + (n.pulseVal * 3); // Expand when pulsed
        ctx.arc(n.x, n.y, drawRadius, 0, Math.PI * 2);
        
        // Fill Color
        let hue, sat, light;
        if (n.isStopped) {
          hue = colorFrozen.h; sat = colorFrozen.s; light = colorFrozen.l;
        } else {
          hue = colorActive.h; sat = colorActive.s; light = colorActive.l + (n.pulseVal * 40); // Flash white
        }
        
        const alpha = 0.4 + (n.z * 0.6); // Fade out distant nodes
        ctx.fillStyle = `hsla(${hue}, ${sat}%, ${light}%, ${alpha})`;
        ctx.fill();
        
        // Glow effect for highly connected nodes (The "Hubs")
        if (n.connections > 5) {
          ctx.beginPath();
          ctx.arc(n.x, n.y, drawRadius * 1.5, 0, Math.PI * 2);
          ctx.fillStyle = `hsla(${hue}, ${sat}%, ${light}%, 0.1)`;
          ctx.fill();
        }
      });
      
      requestAnimationFrame(animate);
    }
    
    // --- CASCADE LOGIC (Preserving the "Overload" feature) ---
    function handleCascadeLogic(n) {
      if (!resetMode) {
        // Start Cascade
        if (!cascadeActive && !resetScheduled && n.connections > 9 && !n.isStopped) {
          n.isStopped = true; n.vx = 0; n.vy = 0; cascadeActive = true; n.pulseVal = 1; // Flash!
        }
        // Spread Cascade
        if (!resetScheduled && !n.isStopped && n.freezeAt === undefined) {
          // Check neighbors
          // Optimization: We check distance in draw loop, could flag there, but simpler here for separate concern
          // Simplified: Random freeze if cascade is active to simulate rapid spread
          if (cascadeActive && Math.random() < 0.01) n.freezeAt = performance.now() + Math.random()*500;
        }
        // Execute Freeze
        if (n.freezeAt && performance.now() > n.freezeAt) {
          n.isStopped = true; n.vx = 0; n.vy = 0; n.freezeAt = undefined; n.pulseVal = 1;
        }
        // Check Full Freeze
        if (cascadeActive && nodes.every(x => x.isStopped) && !resetScheduled) {
          resetScheduled = true;
          setTimeout(() => {
             resetMode = true;
             // Unfreeze one random seed
             const seed = nodes[Math.floor(Math.random()*nodes.length)];
             seed.isStopped = false; seed.originalVx = (Math.random()-0.5); seed.originalVy = (Math.random()-0.5);
          }, 2000);
        }
      } else {
        // Reset Mode (Thaw)
        if (n.isStopped && n.unfreezeAt === undefined) {
           if(Math.random() < 0.02) n.unfreezeAt = performance.now();
        }
        if (n.unfreezeAt && performance.now() > n.unfreezeAt) {
          n.isStopped = false; n.unfreezeAt = undefined; 
          n.vx = (Math.random()-0.5) * (0.2 + n.z * 0.5); 
          n.vy = (Math.random()-0.5) * (0.2 + n.z * 0.5);
          n.pulseVal = 0.5;
        }
        if (nodes.every(x => !x.isStopped)) {
          resetMode = false; cascadeActive = false; resetScheduled = false;
        }
      }
    }
    
    animate();

    /**
     * ==========================================================
     * DATA FETCHERS & UI UPDATES
     * ==========================================================
     */
    
    // -- BITCOIN --
    const btcEl = document.getElementById('bitcoinInfo');
    async function updateBitcoin() {
      try {
        const [heightRes, priceRes] = await Promise.all([
          fetch('https://mempool.space/api/blocks/tip/height'),
          fetch('https://mempool.space/api/v1/prices')
        ]);
        if (!heightRes.ok || !priceRes.ok) throw new Error("API Error");
        
        const height = await heightRes.text();
        const priceData = await priceRes.json();
        
        const fmtPrice = priceData.USD.toLocaleString('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 });
        
        btcEl.innerHTML = `
          <div style="margin-bottom:4px"><span class="btc-label">Block Height</span> <br> <span class="btc-val">${parseInt(height).toLocaleString()}</span></div>
          <div><span class="btc-label">USD Price</span> <br> <span class="btc-val">${fmtPrice}</span></div>
        `;
      } catch (e) {
        btcEl.innerHTML = `<span class="btc-label">Status</span><br><span class="btc-val" style="color:#ef4444">Offline</span>`;
      }
    }
    updateBitcoin();
    setInterval(updateBitcoin, 30000);

    // -- CLOCKS --
    const clockEl = document.getElementById('visitorInfo');
    const cities = [
      { name: "California", tz: "America/Los_Angeles" },
      { name: "New York", tz: "America/New_York" },
      { name: "Addis Ababa", tz: "Africa/Addis_Ababa" },
      { name: "Manama", tz: "Asia/Bahrain" },
      { name: "New Delhi", tz: "Asia/Kolkata" }
    ];
    function updateClocks() {
      const now = new Date();
      let html = '';
      cities.forEach(c => {
        const time = now.toLocaleTimeString([], { timeZone: c.tz, hour: '2-digit', minute: '2-digit' });
        html += `<div class="clock-row"><span class="clock-city">${c.name}</span> <span>${time}</span></div>`;
      });
      clockEl.innerHTML = html;
    }
    updateClocks();
    setInterval(updateClocks, 1000);

    // -- QUOTES --
    const quoteEl = document.getElementById('quotesBox');
    const quotes = [
      "He who has a why to live can bear almost any how.",
      "The doer alone learneth.",
      "In every real man a child is hidden that wants to play.",
      "There are no facts, only interpretations.",
      "Become who you are.",
      "Chaos gives birth to a dancing star.",
      "The snake which cannot cast its skin has to die.",
      "Dig deep; down there is the well of truth."
    ];
    function cycleQuotes() {
      quoteEl.style.opacity = 0;
      setTimeout(() => {
        quoteEl.textContent = quotes[Math.floor(Math.random() * quotes.length)];
        quoteEl.style.opacity = 1;
      }, 500);
    }
    cycleQuotes();
    setInterval(cycleQuotes, 8000);

  </script>
</body>
</html>
