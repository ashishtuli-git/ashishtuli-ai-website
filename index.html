<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ashish Tuli | Neural Quantum</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Space Grotesk', sans-serif;
            background-color: #030305; /* Deep Void */
            color: #e2e8f0;
            overflow: hidden;
            margin: 0;
        }
        #bg-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        #ui-layer {
            position: relative;
            z-index: 10;
            pointer-events: none;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            /* Subtle vignette */
            background: radial-gradient(circle, transparent 40%, #030305 150%);
        }
        .glitch-text {
            position: relative;
            animation: glitch-anim 3s infinite;
        }
        @keyframes glitch-anim {
            0% { transform: translate(0); opacity: 1; }
            95% { transform: translate(0); opacity: 1; }
            96% { transform: translate(-2px, 2px); opacity: 0.8; }
            97% { transform: translate(2px, -2px); opacity: 0.9; }
            98% { transform: translate(0); opacity: 1; }
        }
    </style>
</head>
<body class="antialiased">

    <canvas id="bg-canvas"></canvas>

    <div id="ui-layer">
        <h1 class="glitch-text text-7xl font-bold tracking-tighter text-transparent bg-clip-text bg-gradient-to-r from-blue-400 via-cyan-300 to-white mb-2 opacity-90">
            NEURAL QUANTUM
        </h1>
        <p class="text-sm uppercase tracking-[0.4em] text-cyan-900/80 font-bold">Artificial Intelligence // Quantum Coherence</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Configuration ---
        const CONFIG = {
            particleCount: 500,
            connectionDistance: 35, // How close particles must be to connect
            mouseInteractionRadius: 100, // Area of effect for the "Brain"
            colors: {
                bg: 0x030305,
                nodeInactive: new THREE.Color('#1e293b'), // Dark Blue-Grey (Dormant)
                nodeActive: new THREE.Color('#00ffff'),   // Cyan (AI Active)
                nodeQuantum: new THREE.Color('#a855f7'),  // Purple (Quantum State)
                lines: new THREE.Color('#00ffff')
            }
        };

        let scene, camera, renderer, composer;
        let particlesData = [];
        let positions, colors;
        let particles; // The Point Cloud
        let pointCloud;
        let linesMesh; 
        
        const mouse = new THREE.Vector2(-1000, -1000);
        const raycaster = new THREE.Raycaster();

        function init() {
            // 1. Setup
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.001);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 400;

            const canvas = document.getElementById('bg-canvas');
            renderer = new THREE.WebGLRenderer({ canvas, antialias: false });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);

            // 2. Post-Processing (Bloom for that electric AI feel)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.strength = 1.2;
            bloomPass.radius = 0.2;
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // 3. Create Particles (Nodes)
            // We use Points for performance, but we'll use a custom texture or shape look
            const pGeometry = new THREE.BufferGeometry();
            const pMaterial = new THREE.PointsMaterial({
                color: CONFIG.colors.nodeActive,
                size: 4,
                blending: THREE.AdditiveBlending,
                transparent: true,
                sizeAttenuation: true,
                opacity: 0.8
            });

            positions = new Float32Array(CONFIG.particleCount * 3);
            colors = new Float32Array(CONFIG.particleCount * 3);

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const x = (Math.random() - 0.5) * 800;
                const y = (Math.random() - 0.5) * 800;
                const z = (Math.random() - 0.5) * 800;

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                // Add data object for each particle to manage state
                particlesData.push({
                    velocity: new THREE.Vector3(-1 + Math.random() * 2, -1 + Math.random() * 2, -1 + Math.random() * 2).multiplyScalar(0.2),
                    numConnections: 0,
                    quantumJitter: Math.random() // Unique frequency for vibration
                });
            }

            pGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            pGeometry.setDrawRange(0, CONFIG.particleCount);
            
            pointCloud = new THREE.Points(pGeometry, pMaterial);
            scene.add(pointCloud);

            // 4. Create Lines (The Neural Network)
            // We create a single geometry that can hold MAX possible lines
            // This is more performant than creating/destroying objects
            const geometry = new THREE.BufferGeometry();
            const maxConnections = CONFIG.particleCount * 10; // Estimate
            const linePositions = new Float32Array(maxConnections * 3);
            const lineColors = new Float32Array(maxConnections * 3);

            geometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3).setUsage(THREE.DynamicDrawUsage));
            geometry.setAttribute('color', new THREE.BufferAttribute(lineColors, 3).setUsage(THREE.DynamicDrawUsage));
            
            geometry.computeBoundingSphere();
            geometry.setDrawRange(0, 0);

            const material = new THREE.LineBasicMaterial({
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.3
            });

            linesMesh = new THREE.LineSegments(geometry, material);
            scene.add(linesMesh);

            // 5. Listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousemove', onMouseMove);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function animate() {
            requestAnimationFrame(animate);

            // Time factor
            const time = Date.now() * 0.001;
            
            // Slowly rotate the entire field (The Universe)
            pointCloud.rotation.y += 0.001;
            linesMesh.rotation.y += 0.001;

            // Calculate Mouse Position in 3D Space
            raycaster.setFromCamera(mouse, camera);
            // We use a virtual plane at z=0 (or varies) to catch the mouse
            const rayDir = raycaster.ray.direction;
            const rayOrigin = raycaster.ray.origin;
            // Simple logic: Create a target point in front of camera
            const mouseTarget = new THREE.Vector3().copy(rayOrigin).add(rayDir.multiplyScalar(400)); 

            let vertexpos = 0;
            let colorpos = 0;
            let numConnected = 0;

            // Reset connection counts
            for (let i = 0; i < CONFIG.particleCount; i++) particlesData[i].numConnections = 0;

            // Update Particles
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const data = particlesData[i];

                // 1. Movement (AI Logic: Steady Flow)
                positions[i * 3] += data.velocity.x;
                positions[i * 3 + 1] += data.velocity.y;
                positions[i * 3 + 2] += data.velocity.z;

                // 2. Quantum Jitter (Uncertainty)
                // Add a tiny vibration based on sine waves
                positions[i * 3] += Math.sin(time * 10 + data.quantumJitter) * 0.05; 
                positions[i * 3 + 1] += Math.cos(time * 15 + data.quantumJitter) * 0.05;

                // Bounce off "walls" (keep them in the box)
                if (positions[i * 3] < -400 || positions[i * 3] > 400) data.velocity.x = -data.velocity.x;
                if (positions[i * 3 + 1] < -400 || positions[i * 3 + 1] > 400) data.velocity.y = -data.velocity.y;
                if (positions[i * 3 + 2] < -400 || positions[i * 3 + 2] > 400) data.velocity.z = -data.velocity.z;

                // Check distance to mouse for "Activation"
                // We have to account for the rotation of the group
                const pLocal = new THREE.Vector3(positions[i*3], positions[i*3+1], positions[i*3+2]);
                pLocal.applyMatrix4(pointCloud.matrixWorld); // Transform local to world to compare with mouse
                
                const distToMouse = pLocal.distanceTo(mouseTarget);
                
                // Logic: Is this particle active?
                let isRelevant = distToMouse < CONFIG.mouseInteractionRadius;

                if (isRelevant) {
                    // Neural Activation: Try to find neighbors to connect to
                    // We only check connections for particles NEAR the mouse to save CPU
                    for (let j = i + 1; j < CONFIG.particleCount; j++) {
                        const p2Local = new THREE.Vector3(positions[j*3], positions[j*3+1], positions[j*3+2]);
                        p2Local.applyMatrix4(pointCloud.matrixWorld);

                        const dist = pLocal.distanceTo(p2Local);

                        if (dist < CONFIG.connectionDistance) {
                            particlesData[i].numConnections++;
                            particlesData[j].numConnections++;

                            // Add Line to Buffer
                            const alpha = 1.0 - dist / CONFIG.connectionDistance;

                            // Line Start
                            linesMesh.geometry.attributes.position.array[vertexpos++] = positions[i * 3];
                            linesMesh.geometry.attributes.position.array[vertexpos++] = positions[i * 3 + 1];
                            linesMesh.geometry.attributes.position.array[vertexpos++] = positions[i * 3 + 2];

                            // Line End
                            linesMesh.geometry.attributes.position.array[vertexpos++] = positions[j * 3];
                            linesMesh.geometry.attributes.position.array[vertexpos++] = positions[j * 3 + 1];
                            linesMesh.geometry.attributes.position.array[vertexpos++] = positions[j * 3 + 2];

                            // Colors (Gradient from Cyan to Purple)
                            const color = isRelevant ? CONFIG.colors.nodeActive : CONFIG.colors.nodeInactive;
                            
                            linesMesh.geometry.attributes.color.array[colorpos++] = color.r;
                            linesMesh.geometry.attributes.color.array[colorpos++] = color.g;
                            linesMesh.geometry.attributes.color.array[colorpos++] = color.b;

                            linesMesh.geometry.attributes.color.array[colorpos++] = color.r;
                            linesMesh.geometry.attributes.color.array[colorpos++] = color.g;
                            linesMesh.geometry.attributes.color.array[colorpos++] = color.b;

                            numConnected++;
                        }
                    }
                }
            }

            linesMesh.geometry.setDrawRange(0, numConnected * 2);
            linesMesh.geometry.attributes.position.needsUpdate = true;
            linesMesh.geometry.attributes.color.needsUpdate = true;
            pointCloud.geometry.attributes.position.needsUpdate = true;

            composer.render();
        }

        init();
        animate();
    </script>
</body>
</html>
