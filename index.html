<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ashish Tuli</title>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">

  <style>
    /* -------------------------------------------
       LAYOUT & STYLE
       ------------------------------------------- */
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      overflow: hidden; 
      font-family: 'Inter', sans-serif;
      background: #000;
    }

    /* Background: Deep Void */
    body {
      background: radial-gradient(circle at center, #111827 0%, #000000 100%);
    }

    #neuralCanvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 1;
    }

    /* -------------------------------------------
       UI: GLASSMORPHISM
       ------------------------------------------- */
    .ui-container {
        padding: 0.8rem 1.2rem;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.05); /* Slightly more visible glass */
        backdrop-filter: blur(10px); 
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        transition: transform 0.2s ease, background 0.2s;
    }
    .ui-container:hover {
        background: rgba(255, 255, 255, 0.12);
        border: 1px solid rgba(255, 255, 255, 0.25);
        transform: scale(1.02);
    }

    /* Top Left: Links */
    .top-left-links {
      position: absolute; top: 20px; left: 20px;
      z-index: 5; display: flex; gap: 20px; align-items: center;
    }
    .link-text {
      font-weight: 600; text-decoration: none; color: #fff; letter-spacing: 0.5px; font-size: 1.1rem;
    }
    .double-struck-x {
      font-weight: bold; text-decoration: none; font-size: 1.4rem; color: #fff;
    }

    /* Top Right: Bitcoin */
    #bitcoinInfo {
      position: absolute; top: 20px; right: 20px;
      z-index: 10; color: #eee;
      font-size: 0.9rem; font-weight: 400;
      text-align: right; line-height: 1.4;
      padding: 0.8rem 1.2rem;
    }

    /* Bottom Left: Times */
    .visitor-info {
      position: absolute; bottom: 20px; left: 20px;
      z-index: 3; font-size: 0.9rem; color: #ddd; line-height: 1.6;
    }

    /* Bottom Right: Quotes */
    .quotes {
      position: absolute; bottom: 20px; right: 20px;
      z-index: 3; max-width: 350px;
      font-size: 1rem; font-style: italic; color: #eee; text-align: right;
    }

    /* Mobile */
    @media (max-width: 768px) {
      .visitor-info, .quotes { font-size: 0.8rem; max-width: 250px; }
      .link-text { font-size: 1rem; }
      .ui-container { padding: 0.6rem 0.9rem; }
      .visitor-info { bottom: 90px; } 
    }

    @keyframes pulse {
      0% { transform: scale(1); opacity: 0.9; }
      50% { transform: scale(1.05); opacity: 1; }
      100% { transform: scale(1); opacity: 0.9; }
    }
    #linkedInLink { animation: pulse 3s infinite ease-in-out; }
    #xLink { animation: pulse 3s infinite ease-in-out; animation-delay: 1.5s; }
  </style>
</head>
<body>
  <canvas id="neuralCanvas"></canvas>

  <div class="top-left-links ui-container">
    <a href="https://www.linkedin.com/in/ashishtuli" target="_blank" class="link-text" id="linkedInLink">LinkedIn</a>
    <a href="https://x.com/ashishtuli" target="_blank" class="double-struck-x" id="xLink">&#x1D54F;</a>
  </div>

  <div id="bitcoinInfo" class="ui-container">Loading Bitcoin Data...</div>

  <div class="visitor-info ui-container" id="visitorInfo">
    <div id="timeCalifornia">California: --:--</div>
    <div id="timeNewYork">New York: --:--</div>
    <div id="timeAddisAbaba">Addis Ababa: --:--</div>
    <div id="timeManama">Manama: --:--</div>
    <div id="timeNewDelhi">New Delhi: --:--</div>
  </div>

  <div class="quotes ui-container" id="quotesBox"></div>

  <script>
    /**
     * ==========================================================
     * 3D NEURAL NETWORK V4: Immersive Scale & Visibility
     * ==========================================================
     */
    const canvas = document.getElementById('neuralCanvas');
    const ctx = canvas.getContext('2d');
    
    // 3D Config
    let width, height;
    const fov = 1000; // Larger FOV for immersive feel
    // Increase node count slightly since we are spreading them out more
    const nodeCount = window.innerWidth < 768 ? 50 : 160; 
    let connectionDist = 200; 
    
    // State
    let nodes = [];
    let mouse = { x: 0, y: 0 };
    let targetRotation = { x: 0, y: 0 }; 
    let currentRotation = { x: 0, y: 0 };
    
    // Logic Flags
    let cascadeActive = false;
    let resetMode = false;
    let resetScheduled = false;

    // --- SETUP & RESIZE ---
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      ctx.scale(dpr, dpr);
      canvas.style.width = width + "px";
      canvas.style.height = height + "px";
      
      // Connection distance is relative to the larger dimension now
      connectionDist = Math.max(width, height) * 0.18;
    }
    
    window.addEventListener('resize', () => { resize(); initNodes(); });
    window.addEventListener('mousemove', e => { 
        mouse.x = (e.clientX / width) * 2 - 1;
        mouse.y = (e.clientY / height) * 2 - 1;
    });
    
    resize();

    // --- 3D UTILS ---
    function initNodes() {
      nodes = [];
      // IMMERSIVE SCALE: Use Math.max to ensure sphere is larger than the screen
      const sphereRad = Math.max(width, height) * 0.85; 
      
      for(let i=0; i<nodeCount; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos((Math.random() * 2) - 1);
        const r = (sphereRad * 0.2) + (Math.random() * sphereRad * 0.8); // Fill the volume
        
        nodes.push({
          x: r * Math.sin(phi) * Math.cos(theta),
          y: r * Math.sin(phi) * Math.sin(theta),
          z: r * Math.cos(phi),
          vx: (Math.random() - 0.5) * 2.0, // Faster internal movement
          vy: (Math.random() - 0.5) * 2.0,
          vz: (Math.random() - 0.5) * 2.0,
          ovx: (Math.random() - 0.5) * 2.0,
          ovy: (Math.random() - 0.5) * 2.0,
          ovz: (Math.random() - 0.5) * 2.0,
          connections: 0,
          prevConnections: 0,
          shimmer: 0,
          isStopped: false,
          freezeAt: undefined,
          unfreezeAt: undefined
        });
      }
    }
    initNodes();

    function rotateY(x, z, angle) {
        return { x: x * Math.cos(angle) - z * Math.sin(angle), z: x * Math.sin(angle) + z * Math.cos(angle) };
    }
    function rotateX(y, z, angle) {
        return { y: y * Math.cos(angle) - z * Math.sin(angle), z: y * Math.sin(angle) + z * Math.cos(angle) };
    }

    // --- ANIMATION LOOP ---
    function animate() {
      ctx.clearRect(0, 0, width, height);
      
      targetRotation.y = mouse.x * 0.2; // Slower rotation for massive feel
      targetRotation.x = -mouse.y * 0.2; 
      currentRotation.x += (targetRotation.x - currentRotation.x) * 0.05;
      currentRotation.y += (targetRotation.y - currentRotation.y) * 0.05;
      const autoSpin = performance.now() * 0.0001;
      
      const projectedNodes = [];
      // Bounds allow nodes to fly off screen slightly
      const boxLimit = Math.max(width, height) * 0.9; 

      // 1. UPDATE
      nodes.forEach((n, index) => {
        n.prevConnections = n.connections;
        n.connections = 0; 
        
        if (n.shimmer > 0.01) n.shimmer *= 0.9; else n.shimmer = 0;

        if (!n.isStopped) {
           n.x += n.vx; n.y += n.vy; n.z += n.vz;
           // Soft bounce at very far edges
           if(n.x > boxLimit) n.vx -= 0.1; if(n.x < -boxLimit) n.vx += 0.1;
           if(n.y > boxLimit) n.vy -= 0.1; if(n.y < -boxLimit) n.vy += 0.1;
           if(n.z > boxLimit) n.vz -= 0.1; if(n.z < -boxLimit) n.vz += 0.1;
        }

        handleFreezeLogic(n);

        let p = { x: n.x, y: n.y, z: n.z };
        let r1 = rotateY(p.x, p.z, currentRotation.y + autoSpin);
        p.x = r1.x; p.z = r1.z;
        let r2 = rotateX(p.y, p.z, currentRotation.x);
        p.y = r2.y; p.z = r2.z;
        
        // Push camera back a bit to accommodate large sphere
        let scale = fov / (fov + p.z + 800); 
        let x2d = (p.x * scale) + width/2;
        let y2d = (p.y * scale) + height/2;
        
        projectedNodes.push({ id: index, x: x2d, y: y2d, z: p.z, scale: scale, obj: n });
      });

      projectedNodes.sort((a, b) => b.z - a.z);

      // 2. DRAW LINES (Thicker & Brighter)
      for (let i = 0; i < projectedNodes.length; i++) {
        let p1 = projectedNodes[i];
        for (let j = i + 1; j < projectedNodes.length; j++) {
           let p2 = projectedNodes[j];
           
           let dx = p1.obj.x - p2.obj.x;
           let dy = p1.obj.y - p2.obj.y;
           let dz = p1.obj.z - p2.obj.z;
           let dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

           if (dist < connectionDist) {
              if (p1.obj.isStopped !== p2.obj.isStopped) continue;
              
              p1.obj.connections++;
              p2.obj.connections++;
              
              ctx.beginPath();
              ctx.moveTo(p1.x, p1.y);
              ctx.lineTo(p2.x, p2.y);
              
              let alpha = (p1.scale + p2.scale) * 0.25; // Higher opacity
              if(alpha > 0.8) alpha = 0.8;

              if (p1.obj.isStopped) {
                  ctx.strokeStyle = `rgba(255, 60, 60, ${alpha})`;
                  ctx.lineWidth = 2.5 * p1.scale; // Very thick for frozen
              } else {
                  ctx.strokeStyle = `rgba(200, 220, 255, ${alpha})`; // Bright blue-white
                  ctx.lineWidth = 1.0 * p1.scale; // Thicker base line
              }
              ctx.stroke();
           }
        }
      }

      // 3. DRAW NODES (Bigger & Adaptive)
      projectedNodes.forEach(p => {
         let n = p.obj;
         if (n.connections > n.prevConnections) n.shimmer = 1.0;

         // SIZE LOGIC: Start at 4px, grow by 1.5px per connection
         // Hubs will become massive (e.g., 10 connections = 19px radius)
         let baseRadius = (4 + (n.connections * 1.5)) * p.scale;
         
         ctx.beginPath();
         ctx.arc(p.x, p.y, baseRadius, 0, Math.PI * 2);
         
         if (n.isStopped) {
             let r = 255, g = 60 + (n.shimmer * 195), b = 60 + (n.shimmer * 195);
             ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${p.scale})`;
         } else {
             // Bright white/blue core
             let val = 220 + (n.shimmer * 35); 
             ctx.fillStyle = `rgba(${val}, ${val}, ${val}, ${p.scale})`;
         }
         ctx.fill();
         
         // Glow/Shimmer Ring
         if (n.shimmer > 0.1 || n.connections > 5) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, baseRadius * 1.4, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 255, 255, ${0.15 * p.scale})`;
            ctx.fill();
         }
      });
      
      requestAnimationFrame(animate);
    }
    
    // --- CASCADE LOGIC ---
    function handleFreezeLogic(n) {
        if (!resetMode) {
            // Trigger earlier (at 8 connections) to see it happen more often with bigger nodes
            if (!cascadeActive && !resetScheduled && n.connections > 8 && !n.isStopped) {
                cascadeActive = true; n.isStopped = true; n.vx=0; n.vy=0; n.vz=0;
            }
            if (cascadeActive && !resetScheduled && !n.isStopped) {
                if (Math.random() < 0.02) n.freezeAt = performance.now() + 500;
            }
            if (n.freezeAt && performance.now() > n.freezeAt) {
                 n.isStopped = true; n.vx=0; n.vy=0; n.vz=0; n.freezeAt = undefined;
                 n.shimmer = 1; 
            }
            if (cascadeActive && nodes.every(x => x.isStopped) && !resetScheduled) {
                resetScheduled = true;
                setTimeout(() => {
                    resetMode = true;
                    let idx = Math.floor(Math.random() * nodes.length);
                    nodes[idx].isStopped = false;
                    nodes[idx].vx = nodes[idx].ovx; nodes[idx].vy = nodes[idx].ovy; nodes[idx].vz = nodes[idx].ovz;
                }, 2000);
            }
        } else {
            if (n.isStopped && !n.unfreezeAt && Math.random() < 0.02) {
                 n.unfreezeAt = performance.now() + Math.random()*500;
            }
            if (n.unfreezeAt && performance.now() > n.unfreezeAt) {
                 n.isStopped = false; 
                 n.vx = (Math.random()-0.5)*2.5; n.vy = (Math.random()-0.5)*2.5; n.vz = (Math.random()-0.5)*2.5;
                 n.unfreezeAt = undefined;
                 n.shimmer = 1;
            }
            if (nodes.every(x => !x.isStopped)) {
                resetMode = false; cascadeActive = false; resetScheduled = false;
            }
        }
    }
    
    animate();

    /**
     * ==========================================================
     * DATA APIS
     * ==========================================================
     */
    const btcEl = document.getElementById("bitcoinInfo");
    async function updateBitcoin() {
      try {
        const [h, p] = await Promise.all([
            fetch('https://mempool.space/api/blocks/tip/height'),
            fetch('https://mempool.space/api/v1/prices')
        ]);
        if (!h.ok || !p.ok) throw new Error();
        const height = await h.text();
        const price = await p.json();
        btcEl.innerHTML = `Block: <b>${parseInt(height).toLocaleString()}</b> <br> BTC: <b>${price.USD.toLocaleString('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 })}</b>`;
      } catch (e) { btcEl.textContent = "BTC Data Unavailable"; }
    }
    
    const tEls = {
        ca: document.getElementById("timeCalifornia"),
        ny: document.getElementById("timeNewYork"),
        ad: document.getElementById("timeAddisAbaba"),
        mn: document.getElementById("timeManama"),
        dl: document.getElementById("timeNewDelhi")
    };
    function updateTimes() {
      const now = new Date();
      const f = (z) => `${now.toLocaleTimeString([], {timeZone:z, hour:'2-digit', minute:'2-digit'})}, ${now.toLocaleDateString([], {timeZone:z, month:'short', day:'numeric'})}`;
      tEls.ca.textContent = `California: ${f("America/Los_Angeles")}`;
      tEls.ny.textContent = `New York: ${f("America/New_York")}`;
      tEls.ad.textContent = `Addis Ababa: ${f("Africa/Addis_Ababa")}`;
      tEls.mn.textContent = `Manama: ${f("Asia/Bahrain")}`;
      tEls.dl.textContent = `New Delhi: ${f("Asia/Kolkata")}`;
    }

    const qEl = document.getElementById("quotesBox");
    const quotes = [
      "He who has a why to live can bear almost any how.",
      "That which does not kill us makes us stronger.",
      "In every real man a child is hidden that wants to play.",
      "There are no facts, only interpretations.",
      "Become who you are.",
      "We have art in order not to die of the truth.",
      "Necessity is not an established fact, but an interpretation."
    ];
    function cycleQuotes() {
      qEl.style.opacity = 0;
      setTimeout(() => {
          qEl.textContent = quotes[Math.floor(Math.random() * quotes.length)];
          qEl.style.opacity = 1;
      }, 300);
      setTimeout(cycleQuotes, 10000);
    }

    window.onload = () => {
      updateTimes(); setInterval(updateTimes, 1000);
      cycleQuotes();
      updateBitcoin(); setInterval(updateBitcoin, 30000);
    };
  </script>
</body>
</html>
