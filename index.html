<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ashish Tuli</title>
  <style>
    /*******************************************************
     * Layout & Basic Page Setup
     *******************************************************/
    :root{
      --fg: #eee;
      --frozen: #4B0000;
      --node: rgba(255,255,255,0.9);
      --line: rgba(255,255,255,0.7);
    }

    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
    }

    body {
      overflow: hidden; /* prevent tiny scrollbars from transforms */
      color: var(--fg);
      text-shadow: 0 0 10px rgba(0,0,0,0.35); /* subtle readability boost */
    }

    /* Use sunset background animations exclusively */
    @keyframes sunsetLinearAnim {
      0%   { background: linear-gradient(135deg, #0a0d1a, #1b2340); }
      50%  { background: linear-gradient(135deg, #151a32, #24325a); }
      100% { background: linear-gradient(135deg, #1a2132, #2f3d5c); }
    }
    body.sunset {
      animation: sunsetLinearAnim 20s linear infinite alternate;
    }

    /* Neural network canvas behind everything */
    #neuralCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: none;
      display: block;
    }

    /*******************************************************
     * Top Left Links
     *******************************************************/
    .top-left-links {
      position: absolute;
      top: calc(20px + env(safe-area-inset-top));
      left: calc(20px + env(safe-area-inset-left));
      z-index: 5;
      display: flex;
      gap: 20px;
      align-items: center;
    }

    .myriad-pro {
      font-family: "Myriad Pro Semibold", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      font-weight: 600;
      text-decoration: none;
      color: var(--fg);
    }

    .double-struck-x {
      font-weight: bold;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      text-decoration: none;
      font-size: 1.2rem;
      color: var(--fg);
    }

    /*******************************************************
     * Top Right Bitcoin Info
     *******************************************************/
    #bitcoinInfo {
      position: absolute;
      top: calc(20px + env(safe-area-inset-top));
      right: calc(20px + env(safe-area-inset-right));
      z-index: 10;
      font-family: "Myriad Pro Semibold", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      font-weight: normal;
      font-size: 1rem;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      background: none;
      color: var(--fg);
      font-variant-numeric: tabular-nums; /* prevents jitter when numbers change */
      white-space: nowrap;
    }
    #bitcoinInfo .btc-sub {
      margin-left: 0.6rem;
      font-size: 0.85em;
      opacity: 0.85;
    }

    /*******************************************************
     * Bottom Left Times
     *******************************************************/
    .visitor-info {
      position: absolute;
      bottom: calc(20px + env(safe-area-inset-bottom));
      left: calc(20px + env(safe-area-inset-left));
      z-index: 3;
      font-size: 0.9rem;
      padding: 0.5rem 1rem;
      background: transparent;
      font-variant-numeric: tabular-nums;
    }

    /*******************************************************
     * Bottom Right Quotes
     *******************************************************/
    .quotes {
      position: absolute;
      bottom: calc(20px + env(safe-area-inset-bottom));
      right: calc(20px + env(safe-area-inset-right));
      z-index: 3;
      max-width: 300px;
      font-size: 0.9rem;
      padding: 0.5rem 1rem;
      background: transparent;
      transition: opacity 250ms ease-in-out;
    }
    .quotes.fading {
      opacity: 0;
    }

    /*******************************************************
     * Media Query for Smaller Screens
     *******************************************************/
    @media (max-width: 768px) {
      .visitor-info, .quotes { font-size: 0.8rem; }
      .myriad-pro { font-size: 0.9rem; }
      .double-struck-x { font-size: 1rem; }
      .visitor-info { bottom: calc(60px + env(safe-area-inset-bottom)); }
      .quotes { left: calc(20px + env(safe-area-inset-left)); right: calc(20px + env(safe-area-inset-right)); max-width: none; }
    }

    /*******************************************************
     * Hover / Focus polish (desktop only)
     *******************************************************/
    body *:not(canvas) { transition: transform 0.2s ease-in-out; }

    @media (hover: hover) and (pointer: fine) {
      /* Scale most text on hover, but exclude pulsing links so transforms don't fight */
      body *:not(canvas):not(#linkedInLink):not(#xLink):hover {
        transform: scale(1.05);
      }
      a:hover { text-decoration: none; }
    }

    a:focus-visible {
      outline: 2px solid rgba(255,255,255,0.75);
      outline-offset: 4px;
      border-radius: 6px;
    }

    /*******************************************************
     * Pulse Animation for Top-Left Links
     *******************************************************/
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.03); }
      100% { transform: scale(1); }
    }
    #linkedInLink { animation: pulse 3s infinite ease-in-out; }
    #xLink { animation: pulse 3s infinite ease-in-out; animation-delay: 1.5s; }

    /*******************************************************
     * Reduced motion support
     *******************************************************/
    @media (prefers-reduced-motion: reduce) {
      body.sunset { animation: none; background: linear-gradient(135deg, #0a0d1a, #1b2340); }
      #linkedInLink, #xLink { animation: none; }
      body *:not(canvas) { transition: none; }
    }
  </style>
</head>

<body class="sunset">
  <canvas id="neuralCanvas"></canvas>

  <div class="top-left-links">
    <a href="https://www.linkedin.com/in/ashishtuli" target="_blank" rel="noopener noreferrer"
       class="myriad-pro" id="linkedInLink">LinkedIn</a>
    <a href="https://x.com/ashishtuli" target="_blank" rel="noopener noreferrer"
       class="double-struck-x" id="xLink" aria-label="Ashish Tuli on X">&#x1D54F;</a>
  </div>

  <div id="bitcoinInfo">Loading Bitcoin Info…</div>

  <div class="visitor-info" id="visitorInfo">
    <div id="timeCalifornia">California: --:--</div>
    <div id="timeNewYork">New York: --:--</div>
    <div id="timeAddisAbaba">Addis Ababa: --:--</div>
    <div id="timeManama">Manama: --:--</div>
    <div id="timeNewDelhi">New Delhi: --:--</div>
  </div>

  <div class="quotes" id="quotesBox"></div>

  <script>
    (() => {
      /********************************************************
       * Theme constants
       ********************************************************/
      const fg = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim() || '#eee';
      const deepMaroon = getComputedStyle(document.documentElement).getPropertyValue('--frozen').trim() || '#4B0000';
      const nodeBaseColor = getComputedStyle(document.documentElement).getPropertyValue('--node').trim() || 'rgba(255,255,255,0.9)';
      const lineBaseColor = getComputedStyle(document.documentElement).getPropertyValue('--line').trim() || 'rgba(255,255,255,0.7)';

      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      /********************************************************
       * Bitcoin Info (throttled + cached + paused when hidden)
       ********************************************************/
      const bitcoinInfoElem = document.getElementById("bitcoinInfo");
      bitcoinInfoElem.style.color = fg;

      const BTC_CACHE_KEY = 'btcInfoCache_v1';
      const BTC_REFRESH_MS = 45_000; // subtle but huge improvement vs 1000ms
      const FETCH_TIMEOUT_MS = 8000;
      let btcTimer = null;

      function loadBtcCache() {
        try {
          const raw = localStorage.getItem(BTC_CACHE_KEY);
          if (!raw) return null;
          return JSON.parse(raw);
        } catch {
          return null;
        }
      }

      function saveBtcCache(payload) {
        try { localStorage.setItem(BTC_CACHE_KEY, JSON.stringify(payload)); } catch {}
      }

      function formatUpdatedTime(ts) {
        return new Date(ts).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      }

      function renderBtc({ height, price, updatedAt, stale = false }) {
        const t = formatUpdatedTime(updatedAt);
        bitcoinInfoElem.innerHTML = `
          <span class="btc-main">${height} | $${price}</span>
          <span class="btc-sub">${stale ? 'stale ' : 'updated '}${t}</span>
        `.trim();
        bitcoinInfoElem.title = `Bitcoin block height & spot price (${stale ? 'cached' : 'fresh'})`;
      }

      async function fetchWithTimeout(url, { timeoutMs = FETCH_TIMEOUT_MS } = {}) {
        const controller = new AbortController();
        const id = setTimeout(() => controller.abort(), timeoutMs);
        try {
          const res = await fetch(url, { signal: controller.signal, cache: 'no-store' });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          return res;
        } finally {
          clearTimeout(id);
        }
      }

      async function fetchBlockHeight() {
        // Primary: Blockstream (simple, fast)
        try {
          const r = await fetchWithTimeout('https://blockstream.info/api/blocks/tip/height');
          return (await r.text()).trim();
        } catch {}
        // Fallback: blockchain.info
        const r2 = await fetchWithTimeout('https://blockchain.info/q/getblockcount');
        return (await r2.text()).trim();
      }

      async function fetchBtcPriceUsd() {
        // Primary: Coinbase spot
        try {
          const r = await fetchWithTimeout('https://api.coinbase.com/v2/prices/spot?currency=USD');
          const j = await r.json();
          const amount = Number(j?.data?.amount);
          if (!Number.isFinite(amount)) throw new Error('Bad coinbase payload');
          return Math.round(amount).toString();
        } catch {}
        // Fallback: Coindesk (may be rate limited / changed over time)
        const r2 = await fetchWithTimeout('https://api.coindesk.com/v1/bpi/currentprice.json');
        const j2 = await r2.json();
        const rate = Number(j2?.bpi?.USD?.rate_float);
        if (!Number.isFinite(rate)) throw new Error('Bad coindesk payload');
        return Math.round(rate).toString();
      }

      async function updateBitcoinInfo() {
        try {
          const [height, price] = await Promise.all([fetchBlockHeight(), fetchBtcPriceUsd()]);
          const payload = { height, price, updatedAt: Date.now() };
          renderBtc(payload);
          saveBtcCache(payload);
        } catch (e) {
          const cached = loadBtcCache();
          if (cached?.height && cached?.price && cached?.updatedAt) {
            renderBtc({ ...cached, stale: true });
          } else {
            bitcoinInfoElem.textContent = 'Bitcoin info unavailable';
          }
          // Keep console logging for debugging, but don’t spam UI
          console.error('Error fetching Bitcoin info:', e);
        }
      }

      function startBtcLoop() {
        stopBtcLoop();
        // Update immediately, then schedule next
        updateBitcoinInfo();
        btcTimer = setInterval(() => {
          if (document.visibilityState === 'visible') updateBitcoinInfo();
        }, BTC_REFRESH_MS);
      }

      function stopBtcLoop() {
        if (btcTimer) clearInterval(btcTimer);
        btcTimer = null;
      }

      /********************************************************
       * Times (Bottom Left)
       ********************************************************/
      const tzItems = [
        { id: "timeCalifornia", label: "California", tz: "America/Los_Angeles" },
        { id: "timeNewYork", label: "New York", tz: "America/New_York" },
        { id: "timeAddisAbaba", label: "Addis Ababa", tz: "Africa/Addis_Ababa" },
        { id: "timeManama", label: "Manama", tz: "Asia/Bahrain" },
        { id: "timeNewDelhi", label: "New Delhi", tz: "Asia/Kolkata" },
      ];

      const timeNodes = tzItems.map(x => ({
        el: document.getElementById(x.id),
        label: x.label,
        timeFmt: new Intl.DateTimeFormat([], { timeZone: x.tz, hour: '2-digit', minute: '2-digit' }),
        dateFmt: new Intl.DateTimeFormat([], { timeZone: x.tz, year: 'numeric', month: 'short', day: '2-digit' }),
      }));

      function updateTimes() {
        const now = new Date();
        for (const t of timeNodes) {
          t.el.textContent = `${t.label}: ${t.timeFmt.format(now)}, ${t.dateFmt.format(now)}`;
        }
      }

      document.getElementById('visitorInfo').style.color = fg;
      const quotesBox = document.getElementById('quotesBox');
      quotesBox.style.color = fg;

      /********************************************************
       * Nietzsche Quotes (fade + no immediate repeats)
       ********************************************************/
      const quotesArray = [
        "He who has a why to live can bear almost any how.",
        "That which does not kill us makes us stronger.",
        "In every real man a child is hidden that wants to play.",
        "There are no facts, only interpretations.",
        "Whoever fights monsters should see to it that in the process he does not become a monster.",
        "There is always some madness in love. But there is also always some reason in madness.",
        "Convictions are more dangerous enemies of truth than lies.",
        "The surest way to corrupt a youth is to instruct him to hold in higher esteem those who think alike than those who think differently.",
        "Become who you are.",
        "In individuals, insanity is rare; but in groups, parties, nations, and epochs, it is the rule.",
        "Morality is the herd instinct in the individual.",
        "And those who were seen dancing were thought to be insane by those who could not hear the music.",
        "We have art in order not to die of the truth.",
        "Necessity is not an established fact, but an interpretation.",
        "Admiration for a quality or an art can be so strong that it deters us from striving to possess it."
      ];

      let lastQuoteIndex = -1;

      function pickNextQuoteIndex() {
        if (quotesArray.length <= 1) return 0;
        let idx;
        do { idx = Math.floor(Math.random() * quotesArray.length); }
        while (idx === lastQuoteIndex);
        return idx;
      }

      function setQuote(text) {
        quotesBox.classList.add('fading');
        setTimeout(() => {
          quotesBox.textContent = text;
          quotesBox.classList.remove('fading');
        }, 250);
      }

      function cycleQuotes() {
        const idx = pickNextQuoteIndex();
        lastQuoteIndex = idx;
        setQuote(quotesArray[idx]);
      }

      /********************************************************
       * Neural Network Canvas (faster + sharper)
       ********************************************************/
      const canvas = document.getElementById('neuralCanvas');
      const ctx = canvas.getContext('2d');
      let width, height, dpr;
      let nodes = [];

      const CONNECTION_DIST = 120;
      const CONNECTION_DIST2 = CONNECTION_DIST * CONNECTION_DIST;
      const MOBILE_BREAKPOINT = 768;

      let cascadeActive = false;
      let resetMode = false;
      let resetScheduled = false;

      function resizeCanvas() {
        width = window.innerWidth;
        height = window.innerHeight;
        dpr = window.devicePixelRatio || 1;

        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
        canvas.width = Math.round(width * dpr);
        canvas.height = Math.round(height * dpr);

        // Draw using CSS pixel coordinates
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();

      function initNodes(count) {
        nodes = [];
        for (let i = 0; i < count; i++) {
          nodes.push({
            x: Math.random() * width,
            y: Math.random() * height,
            vx: (Math.random() - 0.5) * 0.6,
            vy: (Math.random() - 0.5) * 0.6,
            currAdjCount: 0,
            lastAdjCount: 0,
            glowEndTime: 0,
            isStopped: false,
            freezeAt: undefined,
            unfreezeAt: undefined,
            resetDelayUntil: undefined
          });
        }
      }

      initNodes(width < MOBILE_BREAKPOINT ? 25 : 121);

      function animateNodes() {
        const now = performance.now();
        ctx.clearRect(0, 0, width, height);

        // Reset connection counts.
        for (const n of nodes) n.currAdjCount = 0;

        // Update positions of active (unfrozen) nodes.
        for (const n of nodes) {
          if (!n.isStopped) {
            n.x += n.vx;
            n.y += n.vy;

            // wrap
            if (n.x < 0) n.x = width;
            if (n.x > width) n.x = 0;
            if (n.y < 0) n.y = height;
            if (n.y > height) n.y = 0;
          }
        }

        // Draw connections for each node pair (squared-distance check).
        for (let i = 0; i < nodes.length; i++) {
          for (let j = i + 1; j < nodes.length; j++) {
            const a = nodes[i], b = nodes[j];
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            const dist2 = dx * dx + dy * dy;

            if (dist2 < CONNECTION_DIST2) {
              // Skip connecting if one is frozen and the other is active.
              if ((a.isStopped && !b.isStopped) || (!a.isStopped && b.isStopped)) continue;

              // Both frozen → deep maroon connection.
              if (a.isStopped && b.isStopped) {
                a.currAdjCount++;
                b.currAdjCount++;
                ctx.beginPath();
                ctx.moveTo(a.x, a.y);
                ctx.lineTo(b.x, b.y);
                ctx.strokeStyle = deepMaroon;
                ctx.lineWidth = 1.2;
                ctx.stroke();
                continue;
              }

              // Both active → obey 1s reset delay for newly unfrozen nodes.
              if (!a.isStopped && !b.isStopped) {
                if ((a.resetDelayUntil && now < a.resetDelayUntil) ||
                    (b.resetDelayUntil && now < b.resetDelayUntil)) {
                  continue;
                }
                a.currAdjCount++;
                b.currAdjCount++;
                ctx.beginPath();
                ctx.moveTo(a.x, a.y);
                ctx.lineTo(b.x, b.y);
                ctx.strokeStyle = lineBaseColor;
                ctx.lineWidth = 1.2;
                ctx.stroke();
              }
            }
          }
        }

        // Freeze / Reset scheduling.
        if (!resetMode) {
          // Find ONE seed node to freeze (break after the first).
          if (!cascadeActive && !resetScheduled) {
            for (let i = 0; i < nodes.length; i++) {
              if (nodes[i].currAdjCount >= 10 && !nodes[i].isStopped) {
                nodes[i].vx = 0;
                nodes[i].vy = 0;
                nodes[i].isStopped = true;
                cascadeActive = true;
                break;
              }
            }
          }

          // For each unfrozen node near a frozen node, schedule freezing with a 600ms delay.
          if (!resetScheduled) {
            for (const n of nodes) {
              if (!n.isStopped && n.freezeAt === undefined) {
                for (const m of nodes) {
                  if (m.isStopped) {
                    const dx = n.x - m.x;
                    const dy = n.y - m.y;
                    if ((dx * dx + dy * dy) < CONNECTION_DIST2) {
                      n.freezeAt = now + 600;
                      break;
                    }
                  }
                }
              }
              if (!n.isStopped && n.freezeAt !== undefined && now >= n.freezeAt) {
                n.vx = 0;
                n.vy = 0;
                n.isStopped = true;
                n.freezeAt = undefined;
              }
            }
          }

          // When all nodes are frozen, schedule the reset cascade.
          if (nodes.every(n => n.isStopped) && !resetScheduled) {
            resetScheduled = true;
            setTimeout(() => {
              resetMode = true;
              const idx = Math.floor(Math.random() * nodes.length);
              nodes[idx].isStopped = false;
              nodes[idx].vx = (Math.random() - 0.5) * 0.6;
              nodes[idx].vy = (Math.random() - 0.5) * 0.6;
              nodes[idx].resetDelayUntil = performance.now() + 1000;
            }, 3000);
          }
        } else {
          // RESET MODE: propagate unfreezing
          for (const n of nodes) {
            if (n.isStopped) {
              let nearUnfrozen = false;
              for (const m of nodes) {
                if (!m.isStopped) {
                  const dx = n.x - m.x;
                  const dy = n.y - m.y;
                  if ((dx * dx + dy * dy) < CONNECTION_DIST2) {
                    nearUnfrozen = true;
                    break;
                  }
                }
              }
              if (nearUnfrozen && n.unfreezeAt === undefined) n.unfreezeAt = now + 600;

              if (n.unfreezeAt !== undefined && now >= n.unfreezeAt) {
                n.isStopped = false;
                n.unfreezeAt = undefined;
                n.vx = (Math.random() - 0.5) * 0.6;
                n.vy = (Math.random() - 0.5) * 0.6;
                n.resetDelayUntil = now + 1000;
              }
            }
          }

          if (nodes.every(n => !n.isStopped)) {
            resetMode = false;
            cascadeActive = false;
            resetScheduled = false;
          }
        }

        // Draw nodes (with glow effect when applicable).
        for (const n of nodes) {
          if (n.currAdjCount > n.lastAdjCount) n.glowEndTime = now + 314;
          n.lastAdjCount = n.currAdjCount;

          const size = 1 + n.currAdjCount * 1.618;

          if (now < n.glowEndTime) {
            ctx.beginPath();
            ctx.arc(n.x, n.y, size + 1.5, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(255,255,0,0.7)";
            ctx.fill();
          }

          ctx.beginPath();
          ctx.arc(n.x, n.y, size, 0, Math.PI * 2);
          ctx.fillStyle = n.isStopped ? deepMaroon : nodeBaseColor;
          ctx.fill();
        }

        requestAnimationFrame(animateNodes);
      }

      /********************************************************
       * Visibility handling
       ********************************************************/
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible') {
          startBtcLoop();
          updateTimes();
        } else {
          stopBtcLoop();
        }
      });

      /********************************************************
       * On Page Load
       ********************************************************/
      // Show cached BTC instantly if available
      const cached = loadBtcCache();
      if (cached?.height && cached?.price && cached?.updatedAt) {
        renderBtc({ ...cached, stale: true });
      }

      updateTimes();
      setInterval(updateTimes, 10_000);

      cycleQuotes();
      setInterval(cycleQuotes, 10_000);

      startBtcLoop();

      // Respect reduced motion: keep layout, reduce animation load
      if (!prefersReducedMotion) {
        requestAnimationFrame(animateNodes);
      } else {
        // Optional: hide the canvas entirely for reduced motion users
        // canvas.style.display = 'none';
      }
    })();
  </script>
</body>
</html>
