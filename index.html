<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ashish Tuli | Quantum Field</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #050505; /* Soft black */
            color: #e2e8f0;
            overflow: hidden;
            margin: 0;
        }
        #bg-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        /* UI Overlay Example */
        #ui-layer {
            position: relative;
            z-index: 10;
            pointer-events: none; /* Let clicks pass through to canvas */
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            background: radial-gradient(circle, transparent 0%, #050505 120%);
        }
    </style>
</head>
<body class="antialiased">

    <canvas id="bg-canvas"></canvas>

    <div id="ui-layer">
        <h1 class="text-6xl font-bold tracking-tighter text-transparent bg-clip-text bg-gradient-to-r from-cyan-300 to-purple-400 mb-4 opacity-90">
            QUANTUM FIELD
        </h1>
        <p class="text-sm uppercase tracking-[0.3em] text-gray-400">Interactive WebGL Experience</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Configuration ---
        const CONFIG = {
            count: 600,
            depth: 600,
            mouseRadius: 40,
            colors: {
                base: new THREE.Color('#00ffd0'), // Neon Cyan
                hover: new THREE.Color('#ff00aa'), // Neon Pink
                entangle: new THREE.Color('#ffffff')
            },
            bloomStrength: 1.5,
            bloomRadius: 0.5,
            bloomThreshold: 0
        };

        let scene, camera, renderer, composer;
        const particles = [];
        const mouse = new THREE.Vector2(-1000, -1000);
        
        // Instanced Meshes
        let circleMesh, boxMesh, triangleMesh;
        const dummy = new THREE.Object3D();

        // Entanglement Management
        const entanglementEffects = [];

        function init() {
            // 1. Scene & Camera
            scene = new THREE.Scene();
            // Add subtle fog for depth cueing
            scene.fog = new THREE.FogExp2(0x050505, 0.0015);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = CONFIG.depth / 2;

            // 2. Renderer
            const canvas = document.getElementById('bg-canvas');
            renderer = new THREE.WebGLRenderer({ canvas, antialias: false, alpha: true }); // Antialias false for performance with Post-Processing
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping;

            // 3. Post-Processing (BLOOM)
            const renderScene = new RenderPass(scene, camera);
            
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight), 
                CONFIG.bloomStrength, 
                CONFIG.bloomRadius, 
                CONFIG.bloomThreshold
            );

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // 4. Geometries (Wireframe looks more "tech")
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, // White, tinted by instance color
                transparent: true,
                opacity: 0.9,
                wireframe: true // Wireframe gives a "data" look
            });

            const circleGeo = new THREE.IcosahedronGeometry(2, 1);
            const boxGeo = new THREE.BoxGeometry(3, 3, 3);
            const triangleGeo = new THREE.ConeGeometry(2, 4, 3);

            // Create Instanced Meshes
            circleMesh = createInstancedMesh(circleGeo, material, CONFIG.count);
            boxMesh = createInstancedMesh(boxGeo, material, CONFIG.count);
            triangleMesh = createInstancedMesh(triangleGeo, material, CONFIG.count);

            scene.add(circleMesh, boxMesh, triangleMesh);

            // 5. Initialize Particles
            for (let i = 0; i < CONFIG.count; i++) {
                const type = Math.floor(Math.random() * 3);
                let mesh = (type === 0) ? circleMesh : (type === 1) ? boxMesh : triangleMesh;
                
                const index = mesh.count++;
                
                // Random Position
                const x = (Math.random() - 0.5) * 300;
                const y = (Math.random() - 0.5) * 300;
                const z = (Math.random() - 0.5) * CONFIG.depth;

                dummy.position.set(x, y, z);
                dummy.updateMatrix();
                mesh.setMatrixAt(index, dummy.matrix);
                mesh.setColorAt(index, CONFIG.colors.base);

                particles.push({
                    mesh,
                    index,
                    pos: new THREE.Vector3(x, y, z),
                    initialPos: new THREE.Vector3(x, y, z),
                    rotationSpeed: {
                        x: (Math.random() - 0.5) * 0.02,
                        y: (Math.random() - 0.5) * 0.02
                    },
                    floatSpeed: 0.5 + Math.random(),
                    floatOffset: Math.random() * Math.PI * 2
                });
            }

            // Update colors initially
            circleMesh.instanceColor.needsUpdate = true;
            boxMesh.instanceColor.needsUpdate = true;
            triangleMesh.instanceColor.needsUpdate = true;

            // 6. Listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousemove', onMouseMove);
            
            // Trigger entanglement periodically
            setInterval(triggerEntanglement, 2000);
        }

        function createInstancedMesh(geo, mat, count) {
            const mesh = new THREE.InstancedMesh(geo, mat, count);
            mesh.count = 0;
            return mesh;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function triggerEntanglement() {
            if (particles.length < 2) return;
            const p1 = particles[Math.floor(Math.random() * particles.length)];
            const p2 = particles[Math.floor(Math.random() * particles.length)];

            // Use Line geometry for sharper, "electric" look
            const points = [p1.pos, p2.pos];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: CONFIG.colors.entangle, 
                transparent: true, 
                opacity: 0.8 
            });
            const line = new THREE.Line(geometry, material);
            
            scene.add(line);
            
            entanglementEffects.push({ line, life: 1.0, p1, p2 });
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now() * 0.001;

            // Move Camera continuously
            camera.position.z -= 0.1;
            if (camera.position.z < -CONFIG.depth / 2) camera.position.z = CONFIG.depth / 2;

            // Calculate Mouse Position in 3D
            const vector = new THREE.Vector3(mouse.x, mouse.y, 0.5).unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const distance = -camera.position.z / dir.z;
            const mousePos3D = camera.position.clone().add(dir.multiplyScalar(distance));

            // Update Particles
            particles.forEach(p => {
                // 1. Floating Animation (Sine wave on Y axis)
                p.pos.y = p.initialPos.y + Math.sin(time * p.floatSpeed + p.floatOffset) * 5;

                // 2. Loop Z position
                let zPos = p.pos.z - camera.position.z;
                if (zPos > CONFIG.depth/2) p.pos.z -= CONFIG.depth;
                if (zPos < -CONFIG.depth/2) p.pos.z += CONFIG.depth;

                // 3. Mouse Interaction (Repulsion + Color)
                const dist = p.pos.distanceTo(mousePos3D);
                let targetColor = CONFIG.colors.base;

                if (dist < CONFIG.mouseRadius) {
                    const repulsionForce = (1 - dist / CONFIG.mouseRadius) * 2;
                    // Push away from mouse
                    const repulsionDir = p.pos.clone().sub(mousePos3D).normalize().multiplyScalar(repulsionForce);
                    p.pos.add(repulsionDir); // Permanently nudges them slightly for organic feel
                    
                    // Lerp Color
                    p.mesh.setColorAt(p.index, CONFIG.colors.hover);
                } else {
                    // Slowly drift back to base color (manual lerp implementation for performance)
                    p.mesh.getColorAt(p.index, targetColor); 
                    if (!targetColor.equals(CONFIG.colors.base)) {
                        targetColor.lerp(CONFIG.colors.base, 0.05);
                        p.mesh.setColorAt(p.index, targetColor);
                    }
                }

                // 4. Update Matrix
                dummy.position.copy(p.pos);
                dummy.rotation.x += p.rotationSpeed.x;
                dummy.rotation.y += p.rotationSpeed.y;
                dummy.updateMatrix();
                p.mesh.setMatrixAt(p.index, dummy.matrix);
            });

            // Update Instanced Meshes
            circleMesh.instanceMatrix.needsUpdate = true;
            boxMesh.instanceMatrix.needsUpdate = true;
            triangleMesh.instanceMatrix.needsUpdate = true;
            circleMesh.instanceColor.needsUpdate = true;
            boxMesh.instanceColor.needsUpdate = true;
            triangleMesh.instanceColor.needsUpdate = true;

            // Update Entanglement Lines
            entanglementEffects.forEach((effect, i) => {
                effect.life -= 0.02;
                if (effect.life <= 0) {
                    scene.remove(effect.line);
                    effect.line.geometry.dispose();
                    effect.line.material.dispose();
                    entanglementEffects.splice(i, 1);
                } else {
                    effect.line.material.opacity = effect.life;
                    // Flash particles connected
                    if(effect.life > 0.8) {
                         effect.p1.mesh.setColorAt(effect.p1.index, CONFIG.colors.entangle);
                         effect.p2.mesh.setColorAt(effect.p2.index, CONFIG.colors.entangle);
                    }
                    // Update line positions (since particles moved)
                    const positions = effect.line.geometry.attributes.position.array;
                    positions[0] = effect.p1.pos.x; positions[1] = effect.p1.pos.y; positions[2] = effect.p1.pos.z;
                    positions[3] = effect.p2.pos.x; positions[4] = effect.p2.pos.y; positions[5] = effect.p2.pos.z;
                    effect.line.geometry.attributes.position.needsUpdate = true;
                }
            });

            // Use Composer instead of Renderer
            composer.render();
        }

        init();
        animate();
    </script>
</body>
</html>
