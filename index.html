<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ashish Tuli</title>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">

  <style>
    /* -------------------------------------------
       LAYOUT & STYLE
       ------------------------------------------- */
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      overflow: hidden; 
      font-family: 'Inter', sans-serif;
      background: #000; /* Deep black base */
    }

    /* Subtle Deep Gradient */
    @keyframes deepSpace {
      0%   { background: radial-gradient(circle at center, #1a2132 0%, #0a0d1a 100%); }
      50%  { background: radial-gradient(circle at center, #24325a 0%, #0a0d1a 100%); }
      100% { background: radial-gradient(circle at center, #1e293b 0%, #0a0d1a 100%); }
    }
    body.sunset { 
      animation: deepSpace 20s ease-in-out infinite alternate; 
    }

    #neuralCanvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 1;
    }

    /* -------------------------------------------
       UI: CLEAN GLASS (Reverted Style)
       ------------------------------------------- */
    .ui-container {
        padding: 0.8rem 1.2rem;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.03); 
        backdrop-filter: blur(8px); 
        -webkit-backdrop-filter: blur(8px);
        border: 1px solid rgba(255, 255, 255, 0.05);
        transition: transform 0.2s ease, background 0.2s;
    }
    .ui-container:hover {
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.15);
        transform: scale(1.02);
    }

    /* Top Left: Links */
    .top-left-links {
      position: absolute; top: 20px; left: 20px;
      z-index: 5; display: flex; gap: 20px; align-items: center;
    }
    .link-text {
      font-weight: 600; text-decoration: none; color: #eee; letter-spacing: 0.5px;
    }
    .double-struck-x {
      font-weight: bold; text-decoration: none; font-size: 1.2rem; color: #eee;
    }

    /* Top Right: Bitcoin */
    #bitcoinInfo {
      position: absolute; top: 20px; right: 20px;
      z-index: 10; color: #eee;
      font-size: 0.85rem; font-weight: 400;
      text-align: right; line-height: 1.4;
      padding: 0.6rem 1rem;
    }

    /* Bottom Left: Times */
    .visitor-info {
      position: absolute; bottom: 20px; left: 20px;
      z-index: 3; font-size: 0.85rem; color: #ccc; line-height: 1.6;
    }

    /* Bottom Right: Quotes */
    .quotes {
      position: absolute; bottom: 20px; right: 20px;
      z-index: 3; max-width: 320px;
      font-size: 0.9rem; font-style: italic; color: #ddd; text-align: right;
    }

    /* Mobile */
    @media (max-width: 768px) {
      .visitor-info, .quotes { font-size: 0.75rem; max-width: 250px; }
      .link-text { font-size: 0.9rem; }
      .ui-container { padding: 0.5rem 0.8rem; }
      .visitor-info { bottom: 80px; } 
    }

    /* Pulse */
    @keyframes pulse {
      0% { transform: scale(1); opacity: 0.9; }
      50% { transform: scale(1.05); opacity: 1; }
      100% { transform: scale(1); opacity: 0.9; }
    }
    #linkedInLink { animation: pulse 3s infinite ease-in-out; }
    #xLink { animation: pulse 3s infinite ease-in-out; animation-delay: 1.5s; }
  </style>
</head>
<body class="sunset">
  <canvas id="neuralCanvas"></canvas>

  <div class="top-left-links ui-container">
    <a href="https://www.linkedin.com/in/ashishtuli" target="_blank" class="link-text" id="linkedInLink">LinkedIn</a>
    <a href="https://x.com/ashishtuli" target="_blank" class="double-struck-x" id="xLink">&#x1D54F;</a>
  </div>

  <div id="bitcoinInfo" class="ui-container">Loading Bitcoin Data...</div>

  <div class="visitor-info ui-container" id="visitorInfo">
    <div id="timeCalifornia">California: --:--</div>
    <div id="timeNewYork">New York: --:--</div>
    <div id="timeAddisAbaba">Addis Ababa: --:--</div>
    <div id="timeManama">Manama: --:--</div>
    <div id="timeNewDelhi">New Delhi: --:--</div>
  </div>

  <div class="quotes ui-container" id="quotesBox"></div>

  <script>
    /**
     * ==========================================================
     * 3D ROTATING NETWORK ENGINE
     * ==========================================================
     */
    const canvas = document.getElementById('neuralCanvas');
    const ctx = canvas.getContext('2d');
    
    // 3D Config
    let width, height;
    const fov = 600; // Field of view
    const nodeCount = window.innerWidth < 768 ? 40 : 100;
    const connectionDist = 150;
    
    // State
    let nodes = [];
    let mouse = { x: 0, y: 0 };
    let targetRotation = { x: 0, y: 0 }; // Controlled by mouse
    let currentRotation = { x: 0, y: 0 }; // Smoothed
    
    // Colors
    const colorActive = { r: 255, g: 255, b: 255 }; 
    const colorFrozen = { r: 255, g: 80, b: 80 }; // Reddish/Maroon for frozen
    
    // Flags
    let cascadeActive = false;
    let resetMode = false;
    let resetScheduled = false;

    // --- SETUP ---
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      ctx.scale(dpr, dpr);
      canvas.style.width = width + "px";
      canvas.style.height = height + "px";
    }
    window.addEventListener('resize', () => { resize(); initNodes(); });
    
    // Mouse interaction controls rotation
    window.addEventListener('mousemove', e => { 
        // Normalize mouse from -1 to 1
        mouse.x = (e.clientX / width) * 2 - 1;
        mouse.y = (e.clientY / height) * 2 - 1;
    });
    
    resize();

    // --- 3D UTILS ---
    function initNodes() {
      nodes = [];
      for(let i=0; i<nodeCount; i++) {
        // Distribute in a random sphere
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos((Math.random() * 2) - 1);
        const r = 200 + Math.random() * 200; // Radius of sphere cloud
        
        nodes.push({
          // 3D position
          x: r * Math.sin(phi) * Math.cos(theta),
          y: r * Math.sin(phi) * Math.sin(theta),
          z: r * Math.cos(phi),
          
          // Velocity (internal movement)
          vx: (Math.random() - 0.5) * 1,
          vy: (Math.random() - 0.5) * 1,
          vz: (Math.random() - 0.5) * 1,
          
          // Original V for unfreeze
          ovx: (Math.random() - 0.5) * 1,
          ovy: (Math.random() - 0.5) * 1,
          ovz: (Math.random() - 0.5) * 1,

          // Logic
          connections: 0,
          isStopped: false,
          freezeAt: undefined,
          unfreezeAt: undefined
        });
      }
    }
    initNodes();

    // Rotate point (x,y,z) around axis
    function rotateY(x, z, angle) {
        return { 
            x: x * Math.cos(angle) - z * Math.sin(angle), 
            z: x * Math.sin(angle) + z * Math.cos(angle) 
        };
    }
    function rotateX(y, z, angle) {
        return { 
            y: y * Math.cos(angle) - z * Math.sin(angle), 
            z: y * Math.sin(angle) + z * Math.cos(angle) 
        };
    }

    // --- ANIMATION LOOP ---
    function animate() {
      ctx.clearRect(0, 0, width, height);
      
      // Smooth Camera Rotation
      targetRotation.y = mouse.x * 0.5; // Yaw
      targetRotation.x = -mouse.y * 0.5; // Pitch
      
      // Auto-rotation override if idle, or just add to it
      currentRotation.x += (targetRotation.x - currentRotation.x) * 0.05;
      currentRotation.y += (targetRotation.y - currentRotation.y) * 0.05;
      
      // Constant background spin
      const autoSpin = performance.now() * 0.0002;
      
      // 1. Update & Project Nodes
      const projectedNodes = [];
      
      nodes.forEach((n, index) => {
        n.connections = 0; // Reset
        
        // Internal Physics (The wiggling inside the cloud)
        if (!n.isStopped) {
           n.x += n.vx; n.y += n.vy; n.z += n.vz;
           
           // Soft boundaries - push back if too far
           const limit = 400;
           if(n.x > limit) n.vx -= 0.05; if(n.x < -limit) n.vx += 0.05;
           if(n.y > limit) n.vy -= 0.05; if(n.y < -limit) n.vy += 0.05;
           if(n.z > limit) n.vz -= 0.05; if(n.z < -limit) n.vz += 0.05;
        }

        // Logic: Cascade Freezing
        handleFreezeLogic(n);

        // 3D Transformation
        // First, apply rotation based on mouse/time
        let p = { x: n.x, y: n.y, z: n.z };
        
        // Rotate Y (Spin)
        let r1 = rotateY(p.x, p.z, currentRotation.y + autoSpin);
        p.x = r1.x; p.z = r1.z;
        
        // Rotate X (Tilt)
        let r2 = rotateX(p.y, p.z, currentRotation.x);
        p.y = r2.y; p.z = r2.z;
        
        // Projection (3D -> 2D)
        // Camera is at z = -fov
        let scale = fov / (fov + p.z + 400); // Offset z so it's in front of camera
        let x2d = (p.x * scale) + width/2;
        let y2d = (p.y * scale) + height/2;
        
        projectedNodes.push({
            id: index,
            x: x2d, y: y2d, z: p.z, scale: scale,
            obj: n
        });
      });

      // Sort by Z (Painter's Algorithm) so back nodes draw first
      projectedNodes.sort((a, b) => b.z - a.z);

      // 2. Draw Connections
      for (let i = 0; i < projectedNodes.length; i++) {
        let p1 = projectedNodes[i];
        
        // Only check forward to avoid duplicates, but check against all (performance hit but accurate)
        // Optimization: only check neighbors in sorted array? No, spatial index needed.
        // Simple O(N^2) is fine for < 150 nodes.
        for (let j = i + 1; j < projectedNodes.length; j++) {
           let p2 = projectedNodes[j];
           
           // Distance Calculation (Visual distance on screen vs 3D distance?)
           // Let's use 3D distance for connectivity logic
           let dx = p1.obj.x - p2.obj.x;
           let dy = p1.obj.y - p2.obj.y;
           let dz = p1.obj.z - p2.obj.z;
           let dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

           if (dist < connectionDist) {
              // Don't connect frozen to active
              if (p1.obj.isStopped !== p2.obj.isStopped) continue;
              
              p1.obj.connections++;
              p2.obj.connections++;
              
              ctx.beginPath();
              ctx.moveTo(p1.x, p1.y);
              ctx.lineTo(p2.x, p2.y);
              
              // Fade based on Z-depth
              let alpha = (p1.scale + p2.scale) / 2 * 0.4; // Base opacity
              if(alpha < 0) alpha = 0;
              
              if (p1.obj.isStopped) {
                  ctx.strokeStyle = `rgba(${colorFrozen.r}, ${colorFrozen.g}, ${colorFrozen.b}, ${alpha * 1.5})`;
                  ctx.lineWidth = 1.5 * p1.scale;
              } else {
                  ctx.strokeStyle = `rgba(${colorActive.r}, ${colorActive.g}, ${colorActive.b}, ${alpha})`;
                  ctx.lineWidth = 0.5 * p1.scale;
              }
              ctx.stroke();
           }
        }
      }

      // 3. Draw Nodes
      projectedNodes.forEach(p => {
         let n = p.obj;
         let radius = (n.isStopped ? 4 : 2) * p.scale; // Frozen nodes pop bigger
         
         ctx.beginPath();
         ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
         
         if (n.isStopped) {
             ctx.fillStyle = `rgba(${colorFrozen.r}, ${colorFrozen.g}, ${colorFrozen.b}, ${p.scale})`;
         } else {
             ctx.fillStyle = `rgba(${colorActive.r}, ${colorActive.g}, ${colorActive.b}, ${p.scale * 0.8})`;
         }
         ctx.fill();
         
         // Halo for active hubs
         if (!n.isStopped && n.connections > 5) {
             ctx.beginPath();
             ctx.arc(p.x, p.y, radius * 3, 0, Math.PI * 2);
             ctx.fillStyle = `rgba(255, 255, 255, ${0.05 * p.scale})`;
             ctx.fill();
         }
      });
      
      requestAnimationFrame(animate);
    }
    
    // --- CASCADE LOGIC ---
    function handleFreezeLogic(n) {
        if (!resetMode) {
            // Trigger Freeze
            if (!cascadeActive && !resetScheduled && n.connections > 10 && !n.isStopped) {
                cascadeActive = true;
                n.isStopped = true; n.vx=0; n.vy=0; n.vz=0; // Stop internal movement
            }
            // Spread Freeze (Proximity Check)
            if (cascadeActive && !resetScheduled && !n.isStopped) {
                // If I am connected to many frozen nodes, I freeze
                // Simplified for performance: Random chance if cascade is on
                if (Math.random() < 0.015) { 
                    n.freezeAt = performance.now() + 500; 
                }
            }
            if (n.freezeAt && performance.now() > n.freezeAt) {
                 n.isStopped = true; n.vx=0; n.vy=0; n.vz=0; n.freezeAt = undefined;
            }
            // Check All Frozen
            if (cascadeActive && nodes.every(x => x.isStopped) && !resetScheduled) {
                resetScheduled = true;
                setTimeout(() => {
                    resetMode = true;
                    // Unfreeze a seed
                    let idx = Math.floor(Math.random() * nodes.length);
                    nodes[idx].isStopped = false;
                    nodes[idx].vx = nodes[idx].ovx; nodes[idx].vy = nodes[idx].ovy; nodes[idx].vz = nodes[idx].ovz;
                }, 2500);
            }
        } else {
            // Thaw
            if (n.isStopped && !n.unfreezeAt && Math.random() < 0.02) {
                 n.unfreezeAt = performance.now() + Math.random()*500;
            }
            if (n.unfreezeAt && performance.now() > n.unfreezeAt) {
                 n.isStopped = false; 
                 // Explode out slightly
                 n.vx = (Math.random()-0.5)*1.5; 
                 n.vy = (Math.random()-0.5)*1.5; 
                 n.vz = (Math.random()-0.5)*1.5;
                 n.unfreezeAt = undefined;
            }
            if (nodes.every(x => !x.isStopped)) {
                resetMode = false; cascadeActive = false; resetScheduled = false;
            }
        }
    }
    
    animate();

    /**
     * ==========================================================
     * UI LOGIC (Bitcoin, Time, Quotes)
     * ==========================================================
     */
    
    // Bitcoin (Mempool API)
    const btcEl = document.getElementById("bitcoinInfo");
    async function updateBitcoin() {
      try {
        const [h, p] = await Promise.all([
            fetch('https://mempool.space/api/blocks/tip/height'),
            fetch('https://mempool.space/api/v1/prices')
        ]);
        if (!h.ok || !p.ok) throw new Error();
        const height = await h.text();
        const price = await p.json();
        btcEl.innerHTML = `Block: <b>${parseInt(height).toLocaleString()}</b> <br> BTC: <b>${price.USD.toLocaleString('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 })}</b>`;
      } catch (e) { btcEl.textContent = "BTC Data Unavailable"; }
    }
    
    // Times
    const tEls = {
        ca: document.getElementById("timeCalifornia"),
        ny: document.getElementById("timeNewYork"),
        ad: document.getElementById("timeAddisAbaba"),
        mn: document.getElementById("timeManama"),
        dl: document.getElementById("timeNewDelhi")
    };
    function updateTimes() {
      const now = new Date();
      const f = (z) => `${now.toLocaleTimeString([], {timeZone:z, hour:'2-digit', minute:'2-digit'})}, ${now.toLocaleDateString([], {timeZone:z, month:'short', day:'numeric'})}`;
      tEls.ca.textContent = `California: ${f("America/Los_Angeles")}`;
      tEls.ny.textContent = `New York: ${f("America/New_York")}`;
      tEls.ad.textContent = `Addis Ababa: ${f("Africa/Addis_Ababa")}`;
      tEls.mn.textContent = `Manama: ${f("Asia/Bahrain")}`;
      tEls.dl.textContent = `New Delhi: ${f("Asia/Kolkata")}`;
    }

    // Quotes
    const qEl = document.getElementById("quotesBox");
    const quotes = [
      "He who has a why to live can bear almost any how.",
      "That which does not kill us makes us stronger.",
      "In every real man a child is hidden that wants to play.",
      "There are no facts, only interpretations.",
      "Become who you are.",
      "We have art in order not to die of the truth.",
      "Necessity is not an established fact, but an interpretation."
    ];
    function cycleQuotes() {
      qEl.style.opacity = 0;
      setTimeout(() => {
          qEl.textContent = quotes[Math.floor(Math.random() * quotes.length)];
          qEl.style.opacity = 1;
      }, 300);
      setTimeout(cycleQuotes, 10000);
    }

    // Init
    window.onload = () => {
      updateTimes(); setInterval(updateTimes, 1000);
      cycleQuotes();
      updateBitcoin(); setInterval(updateBitcoin, 30000);
    };
  </script>
</body>
</html>
