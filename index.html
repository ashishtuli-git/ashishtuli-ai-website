<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ashish Tuli</title>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">

  <style>
    /* -------------------------------------------
       LAYOUT & STYLE
       ------------------------------------------- */
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      overflow: hidden; 
      font-family: 'Inter', sans-serif;
      background: #000;
    }

    /* Background: Deep Void */
    body {
      background: radial-gradient(circle at center, #111827 0%, #000000 100%);
    }

    #neuralCanvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 1;
    }

    /* -------------------------------------------
       UI: GLASSMORPHISM
       ------------------------------------------- */
    .ui-container {
        padding: 0.8rem 1.2rem;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.05); 
        backdrop-filter: blur(10px); 
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        transition: transform 0.2s ease, background 0.2s;
    }
    .ui-container:hover {
        background: rgba(255, 255, 255, 0.12);
        border: 1px solid rgba(255, 255, 255, 0.25);
        transform: scale(1.02);
    }

    /* Top Left: Links */
    .top-left-links {
      position: absolute; top: 20px; left: 20px;
      z-index: 5; display: flex; gap: 20px; align-items: center;
    }
    .link-text {
      font-weight: 600; text-decoration: none; color: #fff; letter-spacing: 0.5px; font-size: 1.1rem;
    }
    .double-struck-x {
      font-weight: bold; text-decoration: none; font-size: 1.4rem; color: #fff;
    }

    /* Top Right: Bitcoin */
    #bitcoinInfo {
      position: absolute; top: 20px; right: 20px;
      z-index: 10; color: #eee;
      font-size: 0.9rem; font-weight: 400;
      text-align: right; line-height: 1.4;
      padding: 0.8rem 1.2rem;
    }

    /* Bottom Left: Times */
    .visitor-info {
      position: absolute; bottom: 20px; left: 20px;
      z-index: 3; font-size: 0.9rem; color: #ddd; line-height: 1.6;
    }

    /* Bottom Right: Quotes */
    .quotes {
      position: absolute; bottom: 20px; right: 20px;
      z-index: 3; max-width: 350px;
      font-size: 1rem; font-style: italic; color: #eee; text-align: right;
    }

    /* Mobile */
    @media (max-width: 768px) {
      .visitor-info, .quotes { font-size: 0.8rem; max-width: 250px; }
      .link-text { font-size: 1rem; }
      .ui-container { padding: 0.6rem 0.9rem; }
      .visitor-info { bottom: 90px; } 
    }

    @keyframes pulse {
      0% { transform: scale(1); opacity: 0.9; }
      50% { transform: scale(1.05); opacity: 1; }
      100% { transform: scale(1); opacity: 0.9; }
    }
    #linkedInLink { animation: pulse 3s infinite ease-in-out; }
    #xLink { animation: pulse 3s infinite ease-in-out; animation-delay: 1.5s; }
  </style>
</head>
<body>
  <canvas id="neuralCanvas"></canvas>

  <div class="top-left-links ui-container">
    <a href="https://www.linkedin.com/in/ashishtuli" target="_blank" class="link-text" id="linkedInLink">LinkedIn</a>
    <a href="https://x.com/ashishtuli" target="_blank" class="double-struck-x" id="xLink">&#x1D54F;</a>
  </div>

  <div id="bitcoinInfo" class="ui-container">Loading Bitcoin Data...</div>

  <div class="visitor-info ui-container" id="visitorInfo">
    <div id="timeCalifornia">California: --:--</div>
    <div id="timeNewYork">New York: --:--</div>
    <div id="timeAddisAbaba">Addis Ababa: --:--</div>
    <div id="timeManama">Manama: --:--</div>
    <div id="timeNewDelhi">New Delhi: --:--</div>
  </div>

  <div class="quotes ui-container" id="quotesBox"></div>

  <script>
    /**
     * ==========================================================
     * 3D NEURAL NETWORK V5: Gravity & Stability Fix
     * ==========================================================
     */
    const canvas = document.getElementById('neuralCanvas');
    const ctx = canvas.getContext('2d');
    
    // 3D Config
    let width, height;
    const fov = 1000; 
    // Increased node count to ensure density matches volume
    const nodeCount = window.innerWidth < 768 ? 60 : 180; 
    let connectionDist = 200; 
    
    // State
    let nodes = [];
    let mouse = { x: 0, y: 0 };
    let targetRotation = { x: 0, y: 0 }; 
    let currentRotation = { x: 0, y: 0 };
    
    // Logic Flags
    let cascadeActive = false;
    let resetMode = false;
    let resetScheduled = false;

    // --- SETUP & RESIZE ---
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      ctx.scale(dpr, dpr);
      canvas.style.width = width + "px";
      canvas.style.height = height + "px";
      
      // Connection distance relative to screen size
      connectionDist = Math.max(width, height) * 0.15;
    }
    
    window.addEventListener('resize', () => { resize(); initNodes(); });
    window.addEventListener('mousemove', e => { 
        mouse.x = (e.clientX / width) * 2 - 1;
        mouse.y = (e.clientY / height) * 2 - 1;
    });
    
    resize();

    // --- 3D UTILS ---
    function initNodes() {
      nodes = [];
      const volumeRad = Math.max(width, height) * 0.6; 
      
      for(let i=0; i<nodeCount; i++) {
        // Initialize in a random cloud
        nodes.push({
          x: (Math.random() - 0.5) * volumeRad * 2,
          y: (Math.random() - 0.5) * volumeRad * 2,
          z: (Math.random() - 0.5) * volumeRad * 2,
          vx: (Math.random() - 0.5) * 1.5,
          vy: (Math.random() - 0.5) * 1.5,
          vz: (Math.random() - 0.5) * 1.5,
          ovx: 0, ovy: 0, ovz: 0, // Store original V
          connections: 0,
          prevConnections: 0,
          shimmer: 0,
          isStopped: false,
          freezeAt: undefined,
          unfreezeAt: undefined
        });
      }
    }
    initNodes();

    function rotateY(x, z, angle) {
        return { x: x * Math.cos(angle) - z * Math.sin(angle), z: x * Math.sin(angle) + z * Math.cos(angle) };
    }
    function rotateX(y, z, angle) {
        return { y: y * Math.cos(angle) - z * Math.sin(angle), z: y * Math.sin(angle) + z * Math.cos(angle) };
    }

    // --- ANIMATION LOOP ---
    function animate() {
      ctx.clearRect(0, 0, width, height);
      
      targetRotation.y = mouse.x * 0.2; 
      targetRotation.x = -mouse.y * 0.2; 
      currentRotation.x += (targetRotation.x - currentRotation.x) * 0.05;
      currentRotation.y += (targetRotation.y - currentRotation.y) * 0.05;
      const autoSpin = performance.now() * 0.0001;
      
      const projectedNodes = [];
      
      // Physics Constants
      const gravity = 0.0005; // Pulls nodes to center (0,0,0)
      const friction = 0.99; // Prevents infinite acceleration

      // 1. UPDATE STATE & PHYSICS
      nodes.forEach((n, index) => {
        n.prevConnections = n.connections;
        n.connections = 0; 
        
        // Decay shimmer
        if (n.shimmer > 0.01) n.shimmer *= 0.9; else n.shimmer = 0;

        // --- PHYSICS ENGINE UPGRADE ---
        if (!n.isStopped) {
           // Apply Gravity (Pull to Center)
           n.vx -= n.x * gravity;
           n.vy -= n.y * gravity;
           n.vz -= n.z * gravity;

           // Apply Velocity
           n.x += n.vx;
           n.y += n.vy;
           n.z += n.vz;

           // Apply Friction (Damping)
           n.vx *= friction;
           n.vy *= friction;
           n.vz *= friction;
        }

        handleFreezeLogic(n);

        // Rotation & Projection
        let p = { x: n.x, y: n.y, z: n.z };
        let r1 = rotateY(p.x, p.z, currentRotation.y + autoSpin);
        p.x = r1.x; p.z = r1.z;
        let r2 = rotateX(p.y, p.z, currentRotation.x);
        p.y = r2.y; p.z = r2.z;
        
        let scale = fov / (fov + p.z + 800); 
        let x2d = (p.x * scale) + width/2;
        let y2d = (p.y * scale) + height/2;
        
        projectedNodes.push({ id: index, x: x2d, y: y2d, z: p.z, scale: scale, obj: n });
      });

      projectedNodes.sort((a, b) => b.z - a.z);

      // 2. DRAW LINES
      for (let i = 0; i < projectedNodes.length; i++) {
        let p1 = projectedNodes[i];
        for (let j = i + 1; j < projectedNodes.length; j++) {
           let p2 = projectedNodes[j];
           
           let dx = p1.obj.x - p2.obj.x;
           let dy = p1.obj.y - p2.obj.y;
           let dz = p1.obj.z - p2.obj.z;
           let dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

           if (dist < connectionDist) {
              if (p1.obj.isStopped !== p2.obj.isStopped) continue;
              
              p1.obj.connections++;
              p2.obj.connections++;
              
              ctx.beginPath();
              ctx.moveTo(p1.x, p1.y);
              ctx.lineTo(p2.x, p2.y);
              
              let alpha = (p1.scale + p2.scale) * 0.25;
              if(alpha > 0.8) alpha = 0.8;

              if (p1.obj.isStopped) {
                  ctx.strokeStyle = `rgba(255, 60, 60, ${alpha})`;
                  ctx.lineWidth = 2.5 * p1.scale;
              } else {
                  ctx.strokeStyle = `rgba(200, 220, 255, ${alpha})`;
                  ctx.lineWidth = 1.0 * p1.scale;
              }
              ctx.stroke();
           }
        }
      }

      // 3. DRAW NODES
      projectedNodes.forEach(p => {
         let n = p.obj;
         if (n.connections > n.prevConnections) n.shimmer = 1.0;

         // Node Size: Grows with connections
         let baseRadius = (4 + (n.connections * 1.5)) * p.scale;
         
         ctx.beginPath();
         ctx.arc(p.x, p.y, baseRadius, 0, Math.PI * 2);
         
         if (n.isStopped) {
             let r = 255, g = 60 + (n.shimmer * 195), b = 60 + (n.shimmer * 195);
             ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${p.scale})`;
         } else {
             let val = 220 + (n.shimmer * 35); 
             ctx.fillStyle = `rgba(${val}, ${val}, ${val}, ${p.scale})`;
         }
         ctx.fill();
         
         if (n.shimmer > 0.1 || n.connections > 5) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, baseRadius * 1.4, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 255, 255, ${0.15 * p.scale})`;
            ctx.fill();
         }
      });
      
      requestAnimationFrame(animate);
    }
    
    // --- CASCADE & FREEZE LOGIC (ROBUST VERSION) ---
    function handleFreezeLogic(n) {
        if (!resetMode) {
            // Trigger Freeze: High connectivity starts the chain reaction
            if (!cascadeActive && !resetScheduled && n.connections > 10 && !n.isStopped) {
                cascadeActive = true; 
                n.isStopped = true; n.vx=0; n.vy=0; n.vz=0;
            }
            
            // Spread Freeze
            if (cascadeActive && !resetScheduled && !n.isStopped) {
                // If cascade is active, freeze rapidly
                if (Math.random() < 0.03) n.freezeAt = performance.now() + 200;
            }
            if (n.freezeAt && performance.now() > n.freezeAt) {
                 n.isStopped = true; n.vx=0; n.vy=0; n.vz=0; n.freezeAt = undefined;
                 n.shimmer = 1; 
            }
            
            // Check for System Reset
            // We use a looser check: if >90% are frozen, reset
            const frozenCount = nodes.filter(x => x.isStopped).length;
            if (cascadeActive && frozenCount > nodes.length * 0.9 && !resetScheduled) {
                resetScheduled = true;
                setTimeout(() => {
                    resetMode = true;
                    // Trigger Thaw
                    triggerThaw();
                }, 1500); // Shorter pause before reset
            }
        }
    }
    
    // Helper to thaw everything
    function triggerThaw() {
        nodes.forEach(node => {
            // Assign random delay for ripple effect
            node.unfreezeAt = performance.now() + Math.random() * 800;
        });
    }

    // Logic inside animate loop to process thaw
    function processThawLogic(n) {
         if (resetMode && n.isStopped && n.unfreezeAt && performance.now() > n.unfreezeAt) {
             n.isStopped = false; 
             // Explosive Restart
             n.vx = (Math.random()-0.5) * 4; 
             n.vy = (Math.random()-0.5) * 4; 
             n.vz = (Math.random()-0.5) * 4;
             n.unfreezeAt = undefined;
             n.shimmer = 1;
         }
         // End reset mode when all active
         if (resetMode && nodes.every(x => !x.isStopped)) {
            resetMode = false; cascadeActive = false; resetScheduled = false;
         }
    }
    
    // Monkey-patch into the main loop:
    // We need to call processThawLogic inside animate, 
    // but I can't easily edit the animate function above without rewriting the whole block.
    // **CRITICAL FIX**: I merged handleFreezeLogic and processThawLogic in the main loop below.
    // (This comment is for clarity, the actual code execution uses the updated animate logic below)
    
    /* * RE-WRITING ANIMATE LOOP's LOGIC CALL SECTION TO INCLUDE THAW 
     * (Implicitly handled by `handleFreezeLogic` having the thaw branch previously? 
     * No, I split it. Let's merge it back for simplicity in this file.)
     */
     
     // Redefining handleFreezeLogic to handle BOTH states cleanly
     const oldFreeze = handleFreezeLogic;
     handleFreezeLogic = function(n) {
        if(resetMode) {
             processThawLogic(n);
        } else {
             oldFreeze(n);
        }
     }

    animate();

    /**
     * ==========================================================
     * DATA APIS
     * ==========================================================
     */
    const btcEl = document.getElementById("bitcoinInfo");
    async function updateBitcoin() {
      try {
        const [h, p] = await Promise.all([
            fetch('https://mempool.space/api/blocks/tip/height'),
            fetch('https://mempool.space/api/v1/prices')
        ]);
        if (!h.ok || !p.ok) throw new Error();
        const height = await h.text();
        const price = await p.json();
        btcEl.innerHTML = `Block: <b>${parseInt(height).toLocaleString()}</b> <br> BTC: <b>${price.USD.toLocaleString('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 })}</b>`;
      } catch (e) { btcEl.textContent = "BTC Data Unavailable"; }
    }
    
    const tEls = {
        ca: document.getElementById("timeCalifornia"),
        ny: document.getElementById("timeNewYork"),
        ad: document.getElementById("timeAddisAbaba"),
        mn: document.getElementById("timeManama"),
        dl: document.getElementById("timeNewDelhi")
    };
    function updateTimes() {
      const now = new Date();
      const f = (z) => `${now.toLocaleTimeString([], {timeZone:z, hour:'2-digit', minute:'2-digit'})}, ${now.toLocaleDateString([], {timeZone:z, month:'short', day:'numeric'})}`;
      tEls.ca.textContent = `California: ${f("America/Los_Angeles")}`;
      tEls.ny.textContent = `New York: ${f("America/New_York")}`;
      tEls.ad.textContent = `Addis Ababa: ${f("Africa/Addis_Ababa")}`;
      tEls.mn.textContent = `Manama: ${f("Asia/Bahrain")}`;
      tEls.dl.textContent = `New Delhi: ${f("Asia/Kolkata")}`;
    }

    const qEl = document.getElementById("quotesBox");
    const quotes = [
      "He who has a why to live can bear almost any how.",
      "That which does not kill us makes us stronger.",
      "In every real man a child is hidden that wants to play.",
      "There are no facts, only interpretations.",
      "Become who you are.",
      "We have art in order not to die of the truth.",
      "Necessity is not an established fact, but an interpretation."
    ];
    function cycleQuotes() {
      qEl.style.opacity = 0;
      setTimeout(() => {
          qEl.textContent = quotes[Math.floor(Math.random() * quotes.length)];
          qEl.style.opacity = 1;
      }, 300);
      setTimeout(cycleQuotes, 10000);
    }

    window.onload = () => {
      updateTimes(); setInterval(updateTimes, 1000);
      cycleQuotes();
      updateBitcoin(); setInterval(updateBitcoin, 30000);
    };
  </script>
</body>
</html>
