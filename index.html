<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ashish Tuli</title>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">

  <style>
    /* -------------------------------------------
       LAYOUT & STYLE
       ------------------------------------------- */
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      overflow: hidden; 
      font-family: 'Inter', sans-serif;
      background: #000;
    }

    /* Background: Deep Void */
    body {
      background: radial-gradient(circle at center, #111827 0%, #000000 100%);
    }

    #neuralCanvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 1;
    }

    /* -------------------------------------------
       UI: GLASSMORPHISM
       ------------------------------------------- */
    .ui-container {
        padding: 0.8rem 1.2rem;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.05); 
        backdrop-filter: blur(10px); 
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        transition: transform 0.2s ease, background 0.2s;
    }
    .ui-container:hover {
        background: rgba(255, 255, 255, 0.12);
        border: 1px solid rgba(255, 255, 255, 0.25);
        transform: scale(1.02);
    }

    /* Top Left: Links */
    .top-left-links {
      position: absolute; top: 20px; left: 20px;
      z-index: 5; display: flex; gap: 20px; align-items: center;
    }
    .link-text {
      font-weight: 600; text-decoration: none; color: #fff; letter-spacing: 0.5px; font-size: 1.1rem;
    }
    .double-struck-x {
      font-weight: bold; text-decoration: none; font-size: 1.4rem; color: #fff;
    }

    /* Top Right: Bitcoin */
    #bitcoinInfo {
      position: absolute; top: 20px; right: 20px;
      z-index: 10; color: #eee;
      font-size: 0.9rem; font-weight: 400;
      text-align: right; line-height: 1.4;
      padding: 0.8rem 1.2rem;
    }

    /* Bottom Left: Times */
    .visitor-info {
      position: absolute; bottom: 20px; left: 20px;
      z-index: 3; font-size: 0.9rem; color: #ddd; line-height: 1.6;
    }

    /* Bottom Right: Quotes */
    .quotes {
      position: absolute; bottom: 20px; right: 20px;
      z-index: 3; max-width: 350px;
      font-size: 1rem; font-style: italic; color: #eee; text-align: right;
    }

    /* Mobile */
    @media (max-width: 768px) {
      .visitor-info, .quotes { font-size: 0.8rem; max-width: 250px; }
      .link-text { font-size: 1rem; }
      .ui-container { padding: 0.6rem 0.9rem; }
      .visitor-info { bottom: 90px; } 
    }

    @keyframes pulse {
      0% { transform: scale(1); opacity: 0.9; }
      50% { transform: scale(1.05); opacity: 1; }
      100% { transform: scale(1); opacity: 0.9; }
    }
    #linkedInLink { animation: pulse 3s infinite ease-in-out; }
    #xLink { animation: pulse 3s infinite ease-in-out; animation-delay: 1.5s; }
  </style>
</head>
<body>
  <canvas id="neuralCanvas"></canvas>

  <div class="top-left-links ui-container">
    <a href="https://www.linkedin.com/in/ashishtuli" target="_blank" class="link-text" id="linkedInLink">LinkedIn</a>
    <a href="https://x.com/ashishtuli" target="_blank" class="double-struck-x" id="xLink">&#x1D54F;</a>
  </div>

  <div id="bitcoinInfo" class="ui-container">Loading Bitcoin Data...</div>

  <div class="visitor-info ui-container" id="visitorInfo">
    <div id="timeCalifornia">California: --:--</div>
    <div id="timeNewYork">New York: --:--</div>
    <div id="timeAddisAbaba">Addis Ababa: --:--</div>
    <div id="timeManama">Manama: --:--</div>
    <div id="timeNewDelhi">New Delhi: --:--</div>
  </div>

  <div class="quotes ui-container" id="quotesBox"></div>

  <script>
    /**
     * ==========================================================
     * 3D NEURAL NETWORK V7: PERPETUAL MOTION
     * ==========================================================
     */
    const canvas = document.getElementById('neuralCanvas');
    const ctx = canvas.getContext('2d');
    
    // 3D Config
    let width, height;
    const fov = 1000; 
    const nodeCount = window.innerWidth < 768 ? 60 : 160; 
    let connectionDist = 200; 
    
    // State
    let nodes = [];
    let mouse = { x: 0, y: 0 };
    let targetRotation = { x: 0, y: 0 }; 
    let currentRotation = { x: 0, y: 0 };
    
    // Logic Flags
    let cascadeActive = false;
    let resetMode = false;
    let resetScheduled = false;

    // --- SETUP & RESIZE ---
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      ctx.scale(dpr, dpr);
      canvas.style.width = width + "px";
      canvas.style.height = height + "px";
      connectionDist = Math.max(width, height) * 0.18;
    }
    window.addEventListener('resize', () => { resize(); initNodes(); });
    window.addEventListener('mousemove', e => { 
        mouse.x = (e.clientX / width) * 2 - 1;
        mouse.y = (e.clientY / height) * 2 - 1;
    });
    resize();

    // --- 3D UTILS ---
    function initNodes() {
      nodes = [];
      const maxDim = Math.max(width, height);
      
      for(let i=0; i<nodeCount; i++) {
        nodes.push({
          x: (Math.random() - 0.5) * maxDim,
          y: (Math.random() - 0.5) * maxDim,
          z: (Math.random() - 0.5) * maxDim,
          vx: (Math.random() - 0.5) * 2,
          vy: (Math.random() - 0.5) * 2,
          vz: (Math.random() - 0.5) * 2,
          connections: 0,
          prevConnections: 0,
          shimmer: 0,
          isStopped: false,
          freezeAt: undefined,
          unfreezeAt: undefined
        });
      }
    }
    initNodes();

    function rotateY(x, z, angle) {
        return { x: x * Math.cos(angle) - z * Math.sin(angle), z: x * Math.sin(angle) + z * Math.cos(angle) };
    }
    function rotateX(y, z, angle) {
        return { y: y * Math.cos(angle) - z * Math.sin(angle), z: y * Math.sin(angle) + z * Math.cos(angle) };
    }

    // --- ANIMATION LOOP ---
    function animate() {
      ctx.clearRect(0, 0, width, height);
      
      targetRotation.y = mouse.x * 0.2; 
      targetRotation.x = -mouse.y * 0.2; 
      currentRotation.x += (targetRotation.x - currentRotation.x) * 0.05;
      currentRotation.y += (targetRotation.y - currentRotation.y) * 0.05;
      const autoSpin = performance.now() * 0.0001;
      
      const projectedNodes = [];
      const boxLimit = Math.max(width, height) * 0.6; 
      
      // 1. PHYSICS UPDATE
      nodes.forEach((n, index) => {
        n.prevConnections = n.connections;
        n.connections = 0; 
        if (n.shimmer > 0.01) n.shimmer *= 0.9; else n.shimmer = 0;

        if (!n.isStopped) {
            // FIX: Thermal Energy (Constant subtle randomness)
            // This prevents them from ever settling into a static state
            n.vx += (Math.random() - 0.5) * 0.08;
            n.vy += (Math.random() - 0.5) * 0.08;
            n.vz += (Math.random() - 0.5) * 0.08;

            // Fishbowl Containment
            if (n.x > boxLimit) n.vx -= 0.08;
            else if (n.x < -boxLimit) n.vx += 0.08;
            
            if (n.y > boxLimit) n.vy -= 0.08;
            else if (n.y < -boxLimit) n.vy += 0.08;

            if (n.z > boxLimit) n.vz -= 0.08;
            else if (n.z < -boxLimit) n.vz += 0.08;

            // Apply velocity
            n.x += n.vx;
            n.y += n.vy;
            n.z += n.vz;

            // Light Friction
            n.vx *= 0.98; n.vy *= 0.98; n.vz *= 0.98;
        }

        // Handle Logic
        if(resetMode) processThawLogic(n);
        else handleFreezeLogic(n);

        // Rotation & Projection
        let p = { x: n.x, y: n.y, z: n.z };
        let r1 = rotateY(p.x, p.z, currentRotation.y + autoSpin);
        p.x = r1.x; p.z = r1.z;
        let r2 = rotateX(p.y, p.z, currentRotation.x);
        p.y = r2.y; p.z = r2.z;
        
        let scale = fov / (fov + p.z + 800); 
        let x2d = (p.x * scale) + width/2;
        let y2d = (p.y * scale) + height/2;
        
        projectedNodes.push({ id: index, x: x2d, y: y2d, z: p.z, scale: scale, obj: n });
      });

      // 2. REPULSION (Anti-Collapse)
      for(let i=0; i<nodes.length; i++) {
          if(nodes[i].isStopped) continue;
          for(let j=i+1; j<nodes.length; j++) {
              if(nodes[j].isStopped) continue;
              let dx = nodes[i].x - nodes[j].x;
              let dy = nodes[i].y - nodes[j].y;
              let dz = nodes[i].z - nodes[j].z;
              let d2 = dx*dx + dy*dy + dz*dz;
              if(d2 < 5000) { 
                  let dist = Math.sqrt(d2);
                  if(dist < 1) dist = 1; 
                  let force = (70 - dist) * 0.0015; // Repulsion force
                  let fx = (dx/dist) * force;
                  let fy = (dy/dist) * force;
                  let fz = (dz/dist) * force;
                  
                  nodes[i].vx += fx; nodes[i].vy += fy; nodes[i].vz += fz;
                  nodes[j].vx -= fx; nodes[j].vy -= fy; nodes[j].vz -= fz;
              }
          }
      }

      projectedNodes.sort((a, b) => b.z - a.z);

      // 3. DRAW LINES
      for (let i = 0; i < projectedNodes.length; i++) {
        let p1 = projectedNodes[i];
        for (let j = i + 1; j < projectedNodes.length; j++) {
           let p2 = projectedNodes[j];
           let dx = p1.obj.x - p2.obj.x;
           let dy = p1.obj.y - p2.obj.y;
           let dz = p1.obj.z - p2.obj.z;
           let dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

           if (dist < connectionDist) {
              if (p1.obj.isStopped !== p2.obj.isStopped) continue;
              p1.obj.connections++; p2.obj.connections++;
              
              ctx.beginPath();
              ctx.moveTo(p1.x, p1.y);
              ctx.lineTo(p2.x, p2.y);
              
              let alpha = (p1.scale + p2.scale) * 0.25;
              if(alpha > 0.8) alpha = 0.8;
              if (p1.obj.isStopped) {
                  ctx.strokeStyle = `rgba(255, 60, 60, ${alpha})`;
                  ctx.lineWidth = 2.5 * p1.scale;
              } else {
                  ctx.strokeStyle = `rgba(200, 220, 255, ${alpha})`;
                  ctx.lineWidth = 1.0 * p1.scale;
              }
              ctx.stroke();
           }
        }
      }

      // 4. DRAW NODES
      projectedNodes.forEach(p => {
         let n = p.obj;
         if (n.connections > n.prevConnections) n.shimmer = 1.0;
         let baseRadius = (4 + (n.connections * 1.5)) * p.scale;
         
         ctx.beginPath();
         ctx.arc(p.x, p.y, baseRadius, 0, Math.PI * 2);
         if (n.isStopped) {
             let r = 255, g = 60 + (n.shimmer * 195), b = 60 + (n.shimmer * 195);
             ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${p.scale})`;
         } else {
             let val = 220 + (n.shimmer * 35); 
             ctx.fillStyle = `rgba(${val}, ${val}, ${val}, ${p.scale})`;
         }
         ctx.fill();
         if (n.shimmer > 0.1 || n.connections > 5) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, baseRadius * 1.4, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 255, 255, ${0.15 * p.scale})`;
            ctx.fill();
         }
      });
      
      requestAnimationFrame(animate);
    }
    
    // --- CASCADE & FREEZE LOGIC ---
    function handleFreezeLogic(n) {
        if (!cascadeActive && !resetScheduled && n.connections > 10 && !n.isStopped) {
            cascadeActive = true; n.isStopped = true; n.vx=0; n.vy=0; n.vz=0;
        }
        if (cascadeActive && !resetScheduled && !n.isStopped) {
            if (Math.random() < 0.03) n.freezeAt = performance.now() + 200;
        }
        if (n.freezeAt && performance.now() > n.freezeAt) {
             n.isStopped = true; n.vx=0; n.vy=0; n.vz=0; n.freezeAt = undefined;
             n.shimmer = 1; 
        }
        const frozenCount = nodes.filter(x => x.isStopped).length;
        if (cascadeActive && frozenCount > nodes.length * 0.9 && !resetScheduled) {
            resetScheduled = true;
            setTimeout(() => { resetMode = true; triggerThaw(); }, 1500);
        }
    }
    
    function triggerThaw() {
        nodes.forEach(node => { node.unfreezeAt = performance.now() + Math.random() * 800; });
    }

    function processThawLogic(n) {
         if (n.isStopped && n.unfreezeAt && performance.now() > n.unfreezeAt) {
             n.isStopped = false; 
             // Explosive Restart
             n.vx = (Math.random()-0.5) * 5; 
             n.vy = (Math.random()-0.5) * 5; 
             n.vz = (Math.random()-0.5) * 5;
             n.unfreezeAt = undefined;
             n.shimmer = 1;
         }
         if (nodes.every(x => !x.isStopped)) {
            resetMode = false; cascadeActive = false; resetScheduled = false;
         }
    }

    animate();

    /**
     * ==========================================================
     * DATA APIS
     * ==========================================================
     */
    const btcEl = document.getElementById("bitcoinInfo");
    async function updateBitcoin() {
      try {
        const [h, p] = await Promise.all([
            fetch('https://mempool.space/api/blocks/tip/height'),
            fetch('https://mempool.space/api/v1/prices')
        ]);
        if (!h.ok || !p.ok) throw new Error();
        const height = await h.text();
        const price = await p.json();
        btcEl.innerHTML = `Block: <b>${parseInt(height).toLocaleString()}</b> <br> BTC: <b>${price.USD.toLocaleString('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 })}</b>`;
      } catch (e) { btcEl.textContent = "BTC Data Unavailable"; }
    }
    
    const tEls = {
        ca: document.getElementById("timeCalifornia"),
        ny: document.getElementById("timeNewYork"),
        ad: document.getElementById("timeAddisAbaba"),
        mn: document.getElementById("timeManama"),
        dl: document.getElementById("timeNewDelhi")
    };
    function updateTimes() {
      const now = new Date();
      const f = (z) => `${now.toLocaleTimeString([], {timeZone:z, hour:'2-digit', minute:'2-digit'})}, ${now.toLocaleDateString([], {timeZone:z, month:'short', day:'numeric'})}`;
      tEls.ca.textContent = `California: ${f("America/Los_Angeles")}`;
      tEls.ny.textContent = `New York: ${f("America/New_York")}`;
      tEls.ad.textContent = `Addis Ababa: ${f("Africa/Addis_Ababa")}`;
      tEls.mn.textContent = `Manama: ${f("Asia/Bahrain")}`;
      tEls.dl.textContent = `New Delhi: ${f("Asia/Kolkata")}`;
    }

    const qEl = document.getElementById("quotesBox");
    const quotes = [
      "He who has a why to live can bear almost any how.",
      "That which does not kill us makes us stronger.",
      "In every real man a child is hidden that wants to play.",
      "There are no facts, only interpretations.",
      "Become who you are.",
      "We have art in order not to die of the truth.",
      "Necessity is not an established fact, but an interpretation."
    ];
    function cycleQuotes() {
      qEl.style.opacity = 0;
      setTimeout(() => {
          qEl.textContent = quotes[Math.floor(Math.random() * quotes.length)];
          qEl.style.opacity = 1;
      }, 300);
      setTimeout(cycleQuotes, 10000);
    }

    window.onload = () => {
      updateTimes(); setInterval(updateTimes, 1000);
      cycleQuotes();
      updateBitcoin(); setInterval(updateBitcoin, 30000);
    };
  </script>
</body>
</html>
