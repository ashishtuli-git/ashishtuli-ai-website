<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ashish Tuli</title>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">

  <style>
    /* -------------------------------------------
       LAYOUT & STYLE
       ------------------------------------------- */
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      overflow: hidden; 
      font-family: 'Inter', sans-serif;
      background: #000;
    }

    /* Subtle Deep Gradient Background */
    @keyframes deepSpace {
      0%   { background: radial-gradient(circle at center, #1a2132 0%, #0a0d1a 100%); }
      50%  { background: radial-gradient(circle at center, #24325a 0%, #0a0d1a 100%); }
      100% { background: radial-gradient(circle at center, #1e293b 0%, #0a0d1a 100%); }
    }
    body.sunset { 
      animation: deepSpace 20s ease-in-out infinite alternate; 
    }

    #neuralCanvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 1;
    }

    /* -------------------------------------------
       UI: GLASSMORPHISM
       ------------------------------------------- */
    .ui-container {
        padding: 0.8rem 1.2rem;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.03); 
        backdrop-filter: blur(8px); 
        -webkit-backdrop-filter: blur(8px);
        border: 1px solid rgba(255, 255, 255, 0.05);
        transition: transform 0.2s ease, background 0.2s;
    }
    .ui-container:hover {
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.15);
        transform: scale(1.02);
    }

    /* Top Left: Links */
    .top-left-links {
      position: absolute; top: 20px; left: 20px;
      z-index: 5; display: flex; gap: 20px; align-items: center;
    }
    .link-text {
      font-weight: 600; text-decoration: none; color: #eee; letter-spacing: 0.5px;
    }
    .double-struck-x {
      font-weight: bold; text-decoration: none; font-size: 1.2rem; color: #eee;
    }

    /* Top Right: Bitcoin */
    #bitcoinInfo {
      position: absolute; top: 20px; right: 20px;
      z-index: 10; color: #eee;
      font-size: 0.85rem; font-weight: 400;
      text-align: right; line-height: 1.4;
      padding: 0.6rem 1rem;
    }

    /* Bottom Left: Times */
    .visitor-info {
      position: absolute; bottom: 20px; left: 20px;
      z-index: 3; font-size: 0.85rem; color: #ccc; line-height: 1.6;
    }

    /* Bottom Right: Quotes */
    .quotes {
      position: absolute; bottom: 20px; right: 20px;
      z-index: 3; max-width: 320px;
      font-size: 0.9rem; font-style: italic; color: #ddd; text-align: right;
    }

    /* Mobile */
    @media (max-width: 768px) {
      .visitor-info, .quotes { font-size: 0.75rem; max-width: 250px; }
      .link-text { font-size: 0.9rem; }
      .ui-container { padding: 0.5rem 0.8rem; }
      .visitor-info { bottom: 80px; } 
    }

    @keyframes pulse {
      0% { transform: scale(1); opacity: 0.9; }
      50% { transform: scale(1.05); opacity: 1; }
      100% { transform: scale(1); opacity: 0.9; }
    }
    #linkedInLink { animation: pulse 3s infinite ease-in-out; }
    #xLink { animation: pulse 3s infinite ease-in-out; animation-delay: 1.5s; }
  </style>
</head>
<body class="sunset">
  <canvas id="neuralCanvas"></canvas>

  <div class="top-left-links ui-container">
    <a href="https://www.linkedin.com/in/ashishtuli" target="_blank" class="link-text" id="linkedInLink">LinkedIn</a>
    <a href="https://x.com/ashishtuli" target="_blank" class="double-struck-x" id="xLink">&#x1D54F;</a>
  </div>

  <div id="bitcoinInfo" class="ui-container">Loading Bitcoin Data...</div>

  <div class="visitor-info ui-container" id="visitorInfo">
    <div id="timeCalifornia">California: --:--</div>
    <div id="timeNewYork">New York: --:--</div>
    <div id="timeAddisAbaba">Addis Ababa: --:--</div>
    <div id="timeManama">Manama: --:--</div>
    <div id="timeNewDelhi">New Delhi: --:--</div>
  </div>

  <div class="quotes ui-container" id="quotesBox"></div>

  <script>
    /**
     * ==========================================================
     * 3D NEURAL NETWORK V3: Resizable Hubs & Shimmer
     * ==========================================================
     */
    const canvas = document.getElementById('neuralCanvas');
    const ctx = canvas.getContext('2d');
    
    // 3D Config
    let width, height;
    const fov = 800; 
    const nodeCount = window.innerWidth < 768 ? 45 : 120;
    // Distance to form connection
    let connectionDist = 150; 
    
    // State
    let nodes = [];
    let mouse = { x: 0, y: 0 };
    let targetRotation = { x: 0, y: 0 }; 
    let currentRotation = { x: 0, y: 0 };
    
    // Logic Flags
    let cascadeActive = false;
    let resetMode = false;
    let resetScheduled = false;

    // --- SETUP & RESIZE ---
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      ctx.scale(dpr, dpr);
      canvas.style.width = width + "px";
      canvas.style.height = height + "px";
      
      // Scale logic: make connection distance relative to screen size so it works on huge monitors
      connectionDist = Math.min(width, height) * 0.15;
    }
    
    window.addEventListener('resize', () => { resize(); initNodes(); });
    window.addEventListener('mousemove', e => { 
        mouse.x = (e.clientX / width) * 2 - 1;
        mouse.y = (e.clientY / height) * 2 - 1;
    });
    
    resize();

    // --- 3D UTILS ---
    function initNodes() {
      nodes = [];
      // Dynamic sphere size to cover screen
      const sphereRad = Math.min(width, height) * 0.45;
      
      for(let i=0; i<nodeCount; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos((Math.random() * 2) - 1);
        const r = (sphereRad * 0.5) + (Math.random() * sphereRad * 0.7); // Spread out
        
        nodes.push({
          // Position
          x: r * Math.sin(phi) * Math.cos(theta),
          y: r * Math.sin(phi) * Math.sin(theta),
          z: r * Math.cos(phi),
          // Velocity
          vx: (Math.random() - 0.5) * 1.5,
          vy: (Math.random() - 0.5) * 1.5,
          vz: (Math.random() - 0.5) * 1.5,
          // Storage for unfreeze
          ovx: (Math.random() - 0.5) * 1.5,
          ovy: (Math.random() - 0.5) * 1.5,
          ovz: (Math.random() - 0.5) * 1.5,
          
          // Logic Stats
          connections: 0,
          prevConnections: 0,
          shimmer: 0, // 0 to 1 intensity
          
          isStopped: false,
          freezeAt: undefined,
          unfreezeAt: undefined
        });
      }
    }
    initNodes();

    function rotateY(x, z, angle) {
        return { x: x * Math.cos(angle) - z * Math.sin(angle), z: x * Math.sin(angle) + z * Math.cos(angle) };
    }
    function rotateX(y, z, angle) {
        return { y: y * Math.cos(angle) - z * Math.sin(angle), z: y * Math.sin(angle) + z * Math.cos(angle) };
    }

    // --- ANIMATION LOOP ---
    function animate() {
      ctx.clearRect(0, 0, width, height);
      
      // Camera Controls
      targetRotation.y = mouse.x * 0.3; 
      targetRotation.x = -mouse.y * 0.3; 
      currentRotation.x += (targetRotation.x - currentRotation.x) * 0.05;
      currentRotation.y += (targetRotation.y - currentRotation.y) * 0.05;
      const autoSpin = performance.now() * 0.0001;
      
      const projectedNodes = [];
      const boxLimit = Math.min(width, height) * 0.6; // Soft boundary

      // 1. UPDATE STATE & PROJECT
      nodes.forEach((n, index) => {
        // Save previous connection count to detect new ones for shimmer
        n.prevConnections = n.connections;
        n.connections = 0; 
        
        // Decay shimmer
        if (n.shimmer > 0.01) n.shimmer *= 0.92; else n.shimmer = 0;

        // Physics
        if (!n.isStopped) {
           n.x += n.vx; n.y += n.vy; n.z += n.vz;
           // Bounce gently
           if(n.x > boxLimit) n.vx -= 0.05; if(n.x < -boxLimit) n.vx += 0.05;
           if(n.y > boxLimit) n.vy -= 0.05; if(n.y < -boxLimit) n.vy += 0.05;
           if(n.z > boxLimit) n.vz -= 0.05; if(n.z < -boxLimit) n.vz += 0.05;
        }

        // Logic
        handleFreezeLogic(n);

        // Rotation
        let p = { x: n.x, y: n.y, z: n.z };
        let r1 = rotateY(p.x, p.z, currentRotation.y + autoSpin);
        p.x = r1.x; p.z = r1.z;
        let r2 = rotateX(p.y, p.z, currentRotation.x);
        p.y = r2.y; p.z = r2.z;
        
        // Projection
        let scale = fov / (fov + p.z + 600); 
        let x2d = (p.x * scale) + width/2;
        let y2d = (p.y * scale) + height/2;
        
        projectedNodes.push({ id: index, x: x2d, y: y2d, z: p.z, scale: scale, obj: n });
      });

      // Sort for Painter's Algorithm
      projectedNodes.sort((a, b) => b.z - a.z);

      // 2. CALCULATE CONNECTIONS & DRAW LINES
      // We calculate connections here to determine size later
      for (let i = 0; i < projectedNodes.length; i++) {
        let p1 = projectedNodes[i];
        for (let j = i + 1; j < projectedNodes.length; j++) {
           let p2 = projectedNodes[j];
           
           // 3D Distance check
           let dx = p1.obj.x - p2.obj.x;
           let dy = p1.obj.y - p2.obj.y;
           let dz = p1.obj.z - p2.obj.z;
           let dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

           if (dist < connectionDist) {
              // Valid connection
              if (p1.obj.isStopped !== p2.obj.isStopped) continue;
              
              p1.obj.connections++;
              p2.obj.connections++;
              
              ctx.beginPath();
              ctx.moveTo(p1.x, p1.y);
              ctx.lineTo(p2.x, p2.y);
              
              let alpha = (p1.scale + p2.scale) * 0.15;
              if (p1.obj.isStopped) {
                  ctx.strokeStyle = `rgba(255, 80, 80, ${alpha})`;
                  ctx.lineWidth = 1.2 * p1.scale;
              } else {
                  ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                  ctx.lineWidth = 0.6 * p1.scale;
              }
              ctx.stroke();
           }
        }
      }

      // 3. CHECK SHIMMER & DRAW NODES
      projectedNodes.forEach(p => {
         let n = p.obj;
         
         // Trigger Shimmer if gained a connection
         if (n.connections > n.prevConnections) n.shimmer = 1.0;

         // Dynamic Size: Base 2 + 0.6 per connection
         // This scales up hubs significantly
         let baseRadius = (2 + (n.connections * 0.8)) * p.scale;
         if (n.isStopped) baseRadius *= 1.2; // Frozen nodes look slightly chunkier

         ctx.beginPath();
         ctx.arc(p.x, p.y, baseRadius, 0, Math.PI * 2);
         
         // Color Mixing
         if (n.isStopped) {
             // Reddish frozen color + shimmer white
             let r = 255, g = 80 + (n.shimmer * 175), b = 80 + (n.shimmer * 175);
             ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${p.scale})`;
         } else {
             // Normal Blue/White + shimmer boost
             let val = 200 + (n.shimmer * 55); 
             // Higher alpha for shimmer
             let alpha = (0.5 * p.scale) + (n.shimmer * 0.5); 
             ctx.fillStyle = `rgba(${val}, ${val}, ${val}, ${alpha})`;
         }
         ctx.fill();
         
         // Extra sparkle for shimmers
         if (n.shimmer > 0.1) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, baseRadius * 2, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 255, 255, ${n.shimmer * 0.3})`;
            ctx.fill();
         }
      });
      
      requestAnimationFrame(animate);
    }
    
    // --- CASCADE LOGIC ---
    function handleFreezeLogic(n) {
        if (!resetMode) {
            if (!cascadeActive && !resetScheduled && n.connections > 12 && !n.isStopped) {
                cascadeActive = true; n.isStopped = true; n.vx=0; n.vy=0; n.vz=0;
            }
            if (cascadeActive && !resetScheduled && !n.isStopped) {
                if (Math.random() < 0.015) n.freezeAt = performance.now() + 500;
            }
            if (n.freezeAt && performance.now() > n.freezeAt) {
                 n.isStopped = true; n.vx=0; n.vy=0; n.vz=0; n.freezeAt = undefined;
                 n.shimmer = 1; // Flash on freeze
            }
            if (cascadeActive && nodes.every(x => x.isStopped) && !resetScheduled) {
                resetScheduled = true;
                setTimeout(() => {
                    resetMode = true;
                    let idx = Math.floor(Math.random() * nodes.length);
                    nodes[idx].isStopped = false;
                    nodes[idx].vx = nodes[idx].ovx; nodes[idx].vy = nodes[idx].ovy; nodes[idx].vz = nodes[idx].ovz;
                }, 2000);
            }
        } else {
            if (n.isStopped && !n.unfreezeAt && Math.random() < 0.02) {
                 n.unfreezeAt = performance.now() + Math.random()*500;
            }
            if (n.unfreezeAt && performance.now() > n.unfreezeAt) {
                 n.isStopped = false; 
                 n.vx = (Math.random()-0.5)*2; n.vy = (Math.random()-0.5)*2; n.vz = (Math.random()-0.5)*2;
                 n.unfreezeAt = undefined;
                 n.shimmer = 1; // Flash on thaw
            }
            if (nodes.every(x => !x.isStopped)) {
                resetMode = false; cascadeActive = false; resetScheduled = false;
            }
        }
    }
    
    animate();

    /**
     * ==========================================================
     * DATA APIS
     * ==========================================================
     */
    const btcEl = document.getElementById("bitcoinInfo");
    async function updateBitcoin() {
      try {
        const [h, p] = await Promise.all([
            fetch('https://mempool.space/api/blocks/tip/height'),
            fetch('https://mempool.space/api/v1/prices')
        ]);
        if (!h.ok || !p.ok) throw new Error();
        const height = await h.text();
        const price = await p.json();
        btcEl.innerHTML = `Block: <b>${parseInt(height).toLocaleString()}</b> <br> BTC: <b>${price.USD.toLocaleString('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 })}</b>`;
      } catch (e) { btcEl.textContent = "BTC Data Unavailable"; }
    }
    
    const tEls = {
        ca: document.getElementById("timeCalifornia"),
        ny: document.getElementById("timeNewYork"),
        ad: document.getElementById("timeAddisAbaba"),
        mn: document.getElementById("timeManama"),
        dl: document.getElementById("timeNewDelhi")
    };
    function updateTimes() {
      const now = new Date();
      const f = (z) => `${now.toLocaleTimeString([], {timeZone:z, hour:'2-digit', minute:'2-digit'})}, ${now.toLocaleDateString([], {timeZone:z, month:'short', day:'numeric'})}`;
      tEls.ca.textContent = `California: ${f("America/Los_Angeles")}`;
      tEls.ny.textContent = `New York: ${f("America/New_York")}`;
      tEls.ad.textContent = `Addis Ababa: ${f("Africa/Addis_Ababa")}`;
      tEls.mn.textContent = `Manama: ${f("Asia/Bahrain")}`;
      tEls.dl.textContent = `New Delhi: ${f("Asia/Kolkata")}`;
    }

    const qEl = document.getElementById("quotesBox");
    const quotes = [
      "He who has a why to live can bear almost any how.",
      "That which does not kill us makes us stronger.",
      "In every real man a child is hidden that wants to play.",
      "There are no facts, only interpretations.",
      "Become who you are.",
      "We have art in order not to die of the truth.",
      "Necessity is not an established fact, but an interpretation."
    ];
    function cycleQuotes() {
      qEl.style.opacity = 0;
      setTimeout(() => {
          qEl.textContent = quotes[Math.floor(Math.random() * quotes.length)];
          qEl.style.opacity = 1;
      }, 300);
      setTimeout(cycleQuotes, 10000);
    }

    window.onload = () => {
      updateTimes(); setInterval(updateTimes, 1000);
      cycleQuotes();
      updateBitcoin(); setInterval(updateBitcoin, 30000);
    };
  </script>
</body>
</html>
